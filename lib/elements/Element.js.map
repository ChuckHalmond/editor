{"version":3,"file":"elements/Element.js","mappings":"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","sources":["webpack://editor/./src/elements/Snippets.ts","webpack://editor/./src/models/Model.ts","webpack://editor/webpack/bootstrap","webpack://editor/webpack/runtime/define property getters","webpack://editor/webpack/runtime/hasOwnProperty shorthand","webpack://editor/./src/elements/Element.ts"],"sourcesContent":["\r\nexport { snakeToCamel };\r\nexport { camelToSnake };\r\nexport { trainToCamel };\r\nexport { camelToTrain };\r\n\r\nfunction snakeToCamel(str: string) {\r\n  return str.split('_').map(str =>  str.charAt(0).toUpperCase() + str.substring(1).toLowerCase()).join(\"\");\r\n}\r\n\r\nfunction camelToSnake(str: string) {\r\n  return str.replace(/(?<!^)(?=[A-Z])/g, '_').toLowerCase();\r\n}\r\n\r\nfunction trainToCamel(str: string) {\r\n  return str.split('-').map(str =>  str.charAt(0).toUpperCase() + str.substring(1).toLowerCase()).join(\"\");\r\n}\r\n\r\nfunction camelToTrain(str: string) {\r\n  return str.replace(/(?<!^)(?=[A-Z])/g, '-').toLowerCase();\r\n}","export { ModelChangeRecord };\r\nexport { ModelEvent };\r\nexport { ModelNode };\r\nexport { ModelObject };\r\nexport { ModelProperty };\r\nexport { ModelList };\r\nexport { ModelChangeObserverOptions };\r\nexport { ModelChangeObserver };\r\n\r\ninterface ModelChangeRecordConstructor {\r\n    prototype: ModelChangeRecord;\r\n    new(\r\n        init: {\r\n            target: ModelNode | ModelList;\r\n            changeType: number;\r\n            propertyName?: string;\r\n            oldValue?: any;\r\n            newValue?: any;\r\n            removedIndex?: number,\r\n            removedItems?: ModelNode[],\r\n            insertedIndex?: number,\r\n            insertedItems?: ModelNode[],\r\n            sortedIndices?: number[]\r\n        }\r\n    ): ModelChangeRecord;\r\n    readonly PROPERTY_CHANGE: number;\r\n    readonly LIST_REMOVE: number;\r\n    readonly LIST_INSERT: number;\r\n    readonly LIST_SORT: number;\r\n}\r\n\r\ninterface ModelChangeRecord {\r\n    readonly target: ModelNode | ModelList\r\n    readonly propertyName: string | null;\r\n    readonly oldValue: any;\r\n    readonly newValue: any;\r\n    readonly changeType: number;\r\n    readonly removedIndex: number;\r\n    readonly removedItems: ModelNodesList;\r\n    readonly insertedIndex: number;\r\n    readonly insertedItems: ModelNodesList;\r\n    readonly sortedIndices: number[];\r\n    readonly PROPERTY_CHANGE: number;\r\n    readonly LIST_REMOVE: number;\r\n    readonly LIST_INSERT: number;\r\n    readonly LIST_SORT: number;\r\n}\r\n\r\nclass ModelChangeRecordBase implements ModelChangeRecord {\r\n    readonly target: ModelNode | ModelList;\r\n    readonly changeType: number;\r\n    readonly propertyName: string | null;\r\n    readonly oldValue: any;\r\n    readonly newValue: any;\r\n    readonly removedIndex: number;\r\n    readonly removedItems: ModelNodesList;\r\n    readonly insertedIndex: number;\r\n    readonly insertedItems: ModelNodesList;\r\n    readonly sortedIndices: number[];\r\n\r\n    constructor(\r\n        init: {\r\n            target: ModelNode | ModelList;\r\n            changeType: number;\r\n            propertyName?: string;\r\n            oldValue?: any;\r\n            newValue?: any;\r\n            removedIndex?: number,\r\n            removedItems?: ModelNode[],\r\n            insertedIndex?: number,\r\n            insertedItems?: ModelNode[],\r\n            sortedIndices?: number[]\r\n        }\r\n    ) {\r\n        this.target = init.target;\r\n        this.changeType = init.changeType;\r\n        this.propertyName = init.propertyName ?? null;\r\n        this.oldValue = init.oldValue ?? undefined;\r\n        this.newValue = init.newValue ?? undefined;\r\n        this.removedIndex = init.removedIndex ?? 0;\r\n        this.removedItems = new ModelNodesList(init.removedItems ?? []);\r\n        this.insertedIndex = init.insertedIndex ?? 0;\r\n        this.insertedItems = new ModelNodesList(init.insertedItems ?? []);\r\n        this.sortedIndices = init.sortedIndices ?? [];\r\n    }\r\n\r\n    static get PROPERTY_CHANGE(): number {\r\n        return 1;\r\n    }\r\n\r\n    static get LIST_REMOVE(): number {\r\n        return 2;\r\n    }\r\n\r\n    static get LIST_INSERT(): number {\r\n        return 3;\r\n    }\r\n\r\n    static get LIST_SORT(): number {\r\n        return 4;\r\n    }\r\n\r\n    get PROPERTY_CHANGE(): number {\r\n        return ModelChangeRecordBase.PROPERTY_CHANGE;\r\n    }\r\n\r\n    get LIST_REMOVE(): number {\r\n        return ModelChangeRecordBase.LIST_REMOVE;\r\n    }\r\n\r\n    get LIST_INSERT(): number {\r\n        return ModelChangeRecordBase.LIST_INSERT;\r\n    }\r\n\r\n    get LIST_SORT(): number {\r\n        return ModelChangeRecordBase.LIST_SORT;\r\n    }\r\n}\r\n\r\nvar ModelChangeRecord: ModelChangeRecordConstructor = ModelChangeRecordBase;\r\n\r\ninterface ModelNodesListConstructor {\r\n    prototype: ModelNodesList;\r\n    new(items: any[]): ModelNodesList;\r\n}\r\n\r\ninterface ModelNodesList {\r\n    get length(): number;\r\n    item(index: number): ModelNode | null;\r\n    values(): IterableIterator<ModelNode>;\r\n}\r\n\r\nclass ModelNodesListBase implements ModelNodesList {\r\n    #items: ModelNode[];\r\n\r\n    constructor(items: ModelNode[]) {\r\n        this.#items = items.slice();\r\n    }\r\n\r\n    get length(): number {\r\n        return this.#items.length;\r\n    }\r\n\r\n    item(index: number): ModelNode | null {\r\n        return this.#items[index] ?? null;\r\n    }\r\n\r\n    values(): IterableIterator<ModelNode> {\r\n        return this.#items.values();\r\n    }\r\n}\r\n\r\nvar ModelNodesList: ModelNodesListConstructor = ModelNodesListBase;\r\n\r\ninterface ModelEventConstructor {\r\n    prototype: ModelEvent;\r\n    new(type: string): ModelEvent;\r\n}\r\n\r\ninterface ModelEvent {\r\n    readonly type: string;\r\n    readonly currentTarget: ModelEventTarget | null;\r\n    readonly target: ModelEventTarget | null;\r\n}\r\n\r\nclass ModelEventBase implements ModelEvent {\r\n    readonly type: string;\r\n\r\n    #currentTarget: ModelEventTarget | null;\r\n    #target: ModelEventTarget | null;\r\n\r\n    constructor(type: string) {\r\n        this.type = type;\r\n        this.#currentTarget = null;\r\n        this.#target = null;\r\n    }\r\n\r\n    get currentTarget(): ModelEventTarget | null {\r\n        return this.#currentTarget;\r\n    }\r\n\r\n    get target(): ModelEventTarget | null {\r\n        return this.#target;\r\n    }\r\n\r\n    static ModelEventTargetAccessor? = new class ModelEventTargetAccessor {\r\n        setCurrentTarget(event: ModelEvent, currentTarget: ModelEventTarget): void {\r\n            if (event instanceof ModelEventBase) {\r\n                event.#currentTarget = currentTarget;\r\n            }\r\n        }\r\n\r\n        setTarget(event: ModelEvent, target: ModelEventTarget): void {\r\n            if (event instanceof ModelEventBase) {\r\n                event.#target = target;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface ModelEventTargetAccessor {\r\n    setCurrentTarget(event: ModelEvent, currentTarget: ModelEventTarget): void;\r\n    setTarget(event: ModelEvent, target: ModelEventTarget): void;\r\n}\r\n\r\nvar ModelEventTargetAccessor: ModelEventTargetAccessor = ModelEventBase.ModelEventTargetAccessor!;\r\ndelete ModelEventBase.ModelEventTargetAccessor;\r\n\r\nvar ModelEvent: ModelEventConstructor = ModelEventBase;\r\n\r\ninterface ModelEventTargetConstructor {\r\n    prototype: ModelEventTarget;\r\n    new(): ModelEventTarget;\r\n}\r\n\r\ninterface ModelEventTarget {\r\n    addEventListener(type: string, callback: (event: ModelEvent) => void): void;\r\n    removeEventListener(type: string, callback: (event: ModelEvent) => void): void;\r\n    dispatchEvent(event: ModelEvent): void;\r\n    receiveEvent(event: ModelEvent): void;\r\n}\r\n\r\nclass ModelEventTargetBase implements ModelEventTarget {\r\n    #callbacks: Map<string, ((event: ModelEvent) => void)[]>;\r\n\r\n    constructor() {\r\n        this.#callbacks = new Map();\r\n    }\r\n\r\n    receiveEvent(event: ModelEvent): void {\r\n        const {type} = event;\r\n        const callbacks = this.#callbacks.get(type);\r\n        ModelEventTargetAccessor.setCurrentTarget(event, this);\r\n        if (callbacks) {\r\n            callbacks.forEach((callback_i) => {\r\n                callback_i(event);\r\n            });\r\n        }\r\n    }\r\n\r\n    addEventListener(type: string, callback: (event: ModelEvent) => void): void {\r\n        const callbacks = this.#callbacks.get(type);\r\n        if (callbacks) {\r\n            callbacks.push(callback);\r\n        }\r\n        else {\r\n            this.#callbacks.set(type, [callback]);\r\n        }\r\n    }\r\n\r\n    removeEventListener(type: string, callback: (event: ModelEvent) => void): void {\r\n        const callbacks = this.#callbacks.get(type);\r\n        if (callbacks) {\r\n            const callbackIndex = callbacks.findIndex(\r\n                callback_i => callback_i == callback\r\n            );\r\n            if (callbackIndex > -1) {\r\n                callbacks.splice(callbackIndex, 1);\r\n            }\r\n            if (callbacks.length == 0) {\r\n                this.#callbacks.delete(type);\r\n            }\r\n        }\r\n    }\r\n\r\n    dispatchEvent(event: ModelEvent): void {\r\n        ModelEventTargetAccessor.setTarget(event, this);\r\n        this.receiveEvent(event);\r\n    }\r\n}\r\n\r\nvar ModelEventTarget: ModelEventTargetConstructor = ModelEventTargetBase;\r\n\r\ninterface ModelNodeConstructor {\r\n    prototype: ModelNode;\r\n    new(): ModelNode;\r\n}\r\n\r\ninterface ModelNode extends ModelEventTarget {\r\n    readonly parentNode: ModelNode | null;\r\n    setParent(parentNode: ModelNode | null): void;\r\n    getRecords(): ModelChangeRecord[];\r\n    beginChanges(): void;\r\n    endChanges(): void;\r\n}\r\n\r\ninterface ModelNodeRecordsAccessor {\r\n    triggerChange(node: ModelNode, property: string, oldValue: any, newValue: any): void;\r\n    handleRecord(node: ModelNode, record: ModelChangeRecord): void;\r\n}\r\n\r\nclass ModelNodeBase extends ModelEventTargetBase implements ModelNode {\r\n    #parentNode: ModelNode | null;\r\n    #records: ModelChangeRecord[];\r\n    #isRecording: boolean;\r\n\r\n    constructor() {\r\n        super();\r\n        this.#parentNode = null;\r\n        this.#records = [];\r\n        this.#isRecording = false;\r\n    }\r\n\r\n    get parentNode(): ModelNode | null {\r\n        return this.#parentNode;\r\n    }\r\n\r\n    setParent(parentNode: ModelNode | null): void {\r\n        if (parentNode !== null) {\r\n            let isCyclicReference = parentNode == this;\r\n            let {parentNode: ancestorNode} = parentNode;\r\n            while (!isCyclicReference && ancestorNode !== null) {\r\n                ({parentNode: ancestorNode} = ancestorNode);\r\n                isCyclicReference = ancestorNode == this;\r\n            }\r\n            if (!isCyclicReference) {\r\n                this.#parentNode = parentNode;\r\n            }\r\n            else {\r\n                throw new TypeError(\"Failed to set parent on ModelNode: circular reference detected in the hierarchy.\");\r\n            }\r\n        }\r\n        else {\r\n            this.#parentNode = null;\r\n        }\r\n    }\r\n    \r\n    beginChanges(): void {\r\n        this.#isRecording = true;\r\n    }\r\n\r\n    endChanges(): void {\r\n        this.dispatchEvent(new ModelEvent(\"modelchange\"));\r\n        this.#records.splice(0);\r\n        this.#isRecording = false;\r\n    }\r\n\r\n    getRecords(): ModelChangeRecord[] {\r\n        return this.#records.slice();\r\n    }\r\n\r\n    receiveEvent(event: ModelEvent): void {\r\n        super.receiveEvent(event);\r\n        const {parentNode} = this;\r\n        if (parentNode) {\r\n            parentNode.receiveEvent(event);\r\n        }\r\n    }\r\n\r\n    #triggerChange(property: string, oldValue: any, newValue: any): void {\r\n        const records = this.#records;\r\n        const record = new ModelChangeRecord({\r\n            target: this,\r\n            changeType: ModelChangeRecord.PROPERTY_CHANGE,\r\n            propertyName: property,\r\n            oldValue, newValue\r\n        });\r\n        records.push(record);\r\n        if (!this.#isRecording) {\r\n            this.dispatchEvent(new ModelEvent(\"modelchange\"));\r\n            records.splice(0);\r\n        }\r\n    }\r\n\r\n    #handleRecord(record: ModelChangeRecord): void {\r\n        this.#records.push(record);\r\n        if (!this.#isRecording) {\r\n            this.dispatchEvent(new ModelEvent(\"modelchange\"));\r\n            this.#records.splice(0);\r\n        }\r\n    }\r\n\r\n    static ModelNodeRecordsAccessor? = new class ModelNodeRecordsAccessor {\r\n        triggerChange(node: ModelNode, property: string, oldValue: any, newValue: any): void {\r\n            if (node instanceof ModelNodeBase) {\r\n                node.#triggerChange(property, oldValue, newValue);\r\n            }\r\n        }\r\n\r\n        handleRecord(node: ModelNode, record: ModelChangeRecord): void {\r\n            if (node instanceof ModelNodeBase) {\r\n                node.#handleRecord(record);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvar ModelNodeRecordsAccessor: ModelNodeRecordsAccessor = ModelNodeBase.ModelNodeRecordsAccessor!;\r\ndelete ModelNodeBase.ModelNodeRecordsAccessor;\r\n\r\nvar ModelNode: ModelNodeConstructor = ModelNodeBase;\r\n\r\ninterface ModelPropertyDecorator {\r\n    (): <Model extends ModelObject>(target: Model, property: string) => void;\r\n}\r\n\r\nconst ModelProperty: ModelPropertyDecorator = function() {\r\n    return (\r\n        target: ModelObject, property: string\r\n    ) => {\r\n        const {constructor} = target;\r\n        const {prototype} = constructor;\r\n        const setter = function(this: ModelObject, value: any) {\r\n            const oldValue = ModelObjectPropertiesAccessor.getProperty(this, property);\r\n            ModelObjectPropertiesAccessor.setProperty(this, property, value);\r\n            if (value !== oldValue) {\r\n                ModelNodeRecordsAccessor.triggerChange(this, property, oldValue, value);\r\n            }\r\n            return true;\r\n        };\r\n        const getter = function(this: ModelObject) {\r\n            return ModelObjectPropertiesAccessor.getProperty(this, property);\r\n        };\r\n        Object.defineProperty(prototype, property, {\r\n            set: setter,\r\n            get: getter,\r\n            enumerable: true\r\n        });\r\n    }\r\n}\r\n\r\ninterface ModelObjectConstructor {\r\n    prototype: ModelObject;\r\n    new(): ModelObject;\r\n}\r\n\r\ninterface ModelObject extends ModelNode {}\r\n\r\ninterface ModelObjectPropertiesAccessor {\r\n    setProperty(node: ModelNode, property: string, value: any): void;\r\n    getProperty(node: ModelNode, property: string,): any;\r\n}\r\n\r\nclass ModelObjectBase extends ModelNodeBase implements ModelObject {\r\n    #properties: Map<string, any>;\r\n\r\n    constructor() {\r\n        super();\r\n        this.#properties = new Map();\r\n    }\r\n\r\n    static ModelObjectPropertiesAccessor? = new class ModelPropertiesAccessor {\r\n        setProperty(node: ModelObject, property: string, value: any): void {\r\n            if (node instanceof ModelObjectBase) {\r\n                node.#properties.set(property, value);\r\n            }\r\n        }\r\n\r\n        getProperty(node: ModelObject, property: string): any {\r\n            if (node instanceof ModelObjectBase) {\r\n                return node.#properties.get(property);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvar ModelObjectPropertiesAccessor: ModelObjectPropertiesAccessor = ModelObjectBase.ModelObjectPropertiesAccessor!;\r\ndelete ModelObjectBase.ModelObjectPropertiesAccessor;\r\n\r\nvar ModelObject: ModelObjectConstructor = ModelObjectBase;\r\n\r\ninterface ModelListConstructor {\r\n    prototype: ModelList;\r\n    new<Model extends ModelNode>(): ModelList<Model>;\r\n    new<Model extends ModelNode>(items: Model[]): ModelList<Model>;\r\n}\r\n\r\ninterface ModelList<Model extends ModelNode = ModelNode> extends ModelNode {\r\n    readonly parentNode: ModelNode | null;\r\n    readonly length: number;\r\n    index(item: Model): number;\r\n    get(index: number): Model | null;\r\n    values(): IterableIterator<Model>;\r\n    sort(compareFunction: (item_a: any, item_b: any) => number): void;\r\n    insert(index: number, ...items: Model[]): void;\r\n    prepend(...items: Model[]): void;\r\n    append(...items: Model[]): void;\r\n    remove(item: Model): void;\r\n    clear(): void;\r\n}\r\n\r\nclass ModelListBase<Model extends ModelNode = ModelNode> extends ModelNodeBase implements ModelList<Model> {\r\n    #items: Model[];\r\n\r\n    constructor()\r\n    constructor(items: Model[])\r\n    constructor(items?: Model[]) {\r\n        super();\r\n        this.#items = items?.slice() ?? [];\r\n    }\r\n\r\n    setParent(parentNode: ModelNode | null): void {\r\n        super.setParent(parentNode);\r\n        this.#items.forEach((item_i) => {\r\n            item_i.setParent(parentNode);\r\n        });\r\n    }\r\n\r\n    get length(): number {\r\n        return this.#items.length;\r\n    }\r\n\r\n    get(index: number): Model | null {\r\n        return this.#items[index] ?? null;\r\n    }\r\n\r\n    index(item: Model): number {\r\n        return this.#items.indexOf(item);\r\n    }\r\n\r\n    values(): IterableIterator<Model> {\r\n        return this.#items.values();\r\n    }\r\n\r\n    sort(compareFunction: (item_a: any, item_b: any) => number): void {\r\n        const items = this.#items;\r\n        const indexedItems = items.map(\r\n            (item_i, i) => {\r\n                return {\r\n                    item: item_i,\r\n                    index: i\r\n                };\r\n            }\r\n        );\r\n        indexedItems.sort(\r\n            (indexedItem_a, indexedItem_b) => {\r\n                return compareFunction(\r\n                    indexedItem_a.item, indexedItem_b.item\r\n                )\r\n            }\r\n        );\r\n        this.#items = indexedItems.map(indexedItem_i => indexedItem_i.item);\r\n        const record = new ModelChangeRecord({\r\n            target: this,\r\n            changeType: ModelChangeRecord.LIST_SORT,\r\n            sortedIndices: indexedItems.map(indexedItem_i => indexedItem_i.index)\r\n        });\r\n        ModelNodeRecordsAccessor.handleRecord(this, record);\r\n    }\r\n\r\n    prepend(...items: Model[]): void {\r\n        const _items = this.#items;\r\n        const {parentNode} = this;\r\n        if (parentNode) {\r\n            items.forEach(item_i => {\r\n                item_i.setParent(parentNode);\r\n            });\r\n        }\r\n        _items.splice(0, 0, ...items);\r\n        const record = new ModelChangeRecord({\r\n            target: this,\r\n            changeType: ModelChangeRecord.LIST_INSERT,\r\n            insertedIndex: 0,\r\n            insertedItems: items\r\n        });\r\n        ModelNodeRecordsAccessor.handleRecord(this, record);\r\n    }\r\n\r\n    append(...items: Model[]): void {\r\n        const _items = this.#items;\r\n        const {length} = _items;\r\n        const {parentNode} = this;\r\n        if (parentNode) {\r\n            items.forEach(item_i => {\r\n                item_i.setParent(parentNode);\r\n            });\r\n        }\r\n        _items.push(...items);\r\n        const record = new ModelChangeRecord({\r\n            target: this,\r\n            changeType: ModelChangeRecord.LIST_INSERT,\r\n            insertedIndex: length,\r\n            insertedItems: items\r\n        });\r\n        ModelNodeRecordsAccessor.handleRecord(this, record);\r\n    }\r\n\r\n    insert(index: number, ...items: Model[]): void {\r\n        const _items = this.#items;\r\n        const {length} = _items;\r\n        const positiveIndex = Math.abs(index);\r\n        if (positiveIndex <= length) {\r\n            if (index >= 0) {\r\n                const {parentNode} = this;\r\n                items.forEach(item_i => {\r\n                    item_i.setParent(parentNode);\r\n                });\r\n                if (index < length) {\r\n                    _items.splice(index, 0, ...items);\r\n                }\r\n                else {\r\n                    _items.push(...items);\r\n                }\r\n            }\r\n            else if (index < 0) {\r\n                index = length - index;\r\n                const {parentNode} = this;\r\n                if (parentNode) {\r\n                    items.forEach(item_i => {\r\n                        item_i.setParent(parentNode);\r\n                    });\r\n                }\r\n                _items.splice(index, 0, ...items);\r\n            }\r\n            const record = new ModelChangeRecord({\r\n                target: this,\r\n                changeType: ModelChangeRecord.LIST_INSERT,\r\n                insertedIndex: index,\r\n                insertedItems: items.slice()\r\n            });\r\n            ModelNodeRecordsAccessor.handleRecord(this, record);\r\n        }\r\n    }\r\n\r\n    remove(item: Model): void {\r\n        const _items = this.#items;\r\n        const index = _items.indexOf(item);\r\n        if (index > -1) {\r\n            const item = _items.splice(index, 1)[0];\r\n            const {parentNode} = this;\r\n            if (parentNode) {\r\n                item.setParent(null);\r\n            }\r\n            const record = new ModelChangeRecord({\r\n                target: this,\r\n                changeType: ModelChangeRecord.LIST_REMOVE,\r\n                removedIndex: index,\r\n                removedItems: [item]\r\n            });\r\n            ModelNodeRecordsAccessor.handleRecord(this, record);\r\n        }\r\n    }\r\n\r\n    clear(): void {\r\n        const items = this.#items;\r\n        const {length} = items;\r\n        if (length > 0) {\r\n            const removedItems = items.splice(0);\r\n            const {parentNode} = this;\r\n            if (parentNode) {\r\n                removedItems.forEach((removedItem_i) => {\r\n                    removedItem_i.setParent(null);\r\n                });\r\n            }\r\n            const record = new ModelChangeRecord({\r\n                target: this,\r\n                changeType: ModelChangeRecord.LIST_REMOVE,\r\n                removedIndex: 0,\r\n                removedItems: removedItems\r\n            });\r\n            ModelNodeRecordsAccessor.handleRecord(this, record);\r\n        }\r\n    }\r\n};\r\n\r\nvar ModelList: ModelListConstructor = ModelListBase!;\r\n\r\ninterface ModelChangeObserverConstructor {\r\n    prototype: ModelChangeObserver;\r\n    new(callback: (records: ModelChangeRecord[]) => void): ModelChangeObserver;\r\n}\r\n\r\ninterface ModelChangeObserver {\r\n    observe(node: ModelNode, options: ModelChangeObserverOptions): void;\r\n    unobserve(node: ModelNode): void;\r\n    disconnect(): void;\r\n}\r\n\r\ntype ModelChangeObserverOptions = {\r\n    properties?: boolean;\r\n    propertiesFilter?: string[];\r\n    childList?: boolean;\r\n    subtree?: boolean;\r\n}\r\n\r\nclass ModelChangeObserverBase implements ModelChangeObserver {\r\n    #callback: (records: ModelChangeRecord[]) => void;\r\n    #records: ModelChangeRecord[];\r\n    #disconnected: boolean;\r\n\r\n    #references: WeakMap<ModelNode, {\r\n        listener: (event: ModelEvent) => void,\r\n        options: ModelChangeObserverOptions\r\n    }>;\r\n\r\n    constructor(callback: (records: ModelChangeRecord[]) => void) {\r\n        this.#callback = callback;\r\n        this.#records = [];\r\n        this.#disconnected = false;\r\n        this.#references = new WeakMap();\r\n    }\r\n\r\n    observe(node: ModelNode, options: ModelChangeObserverOptions): void {\r\n        this.#disconnected = false;\r\n        const references = this.#references;\r\n        let reference = references.get(node);\r\n        if (!reference) {\r\n            const listener = this.#handleModelEvent.bind(this);\r\n            node.addEventListener(\"modelchange\", listener);\r\n            reference = {listener, options};\r\n            references.set(node, reference);\r\n        }\r\n        else {\r\n            references.set(node, reference);\r\n        }\r\n    }\r\n\r\n    unobserve(node: ModelNode): void {\r\n        const references = this.#references;\r\n        let reference = references.get(node);\r\n        if (reference) {\r\n            const {listener} = reference;\r\n            node.removeEventListener(\"modelchange\", listener);\r\n        }\r\n    }\r\n\r\n    disconnect(): void {\r\n        this.#records.splice(0);\r\n        this.#disconnected = true;\r\n    }\r\n\r\n    #trigger(): void {\r\n        const records = this.#records.splice(0);\r\n        if (records.length > 0) {\r\n            this.#callback(records);\r\n        }\r\n    }\r\n\r\n    #handleModelEvent(event: ModelEvent): void {\r\n        if (!this.#disconnected) {\r\n            const {target, currentTarget} = event;\r\n            const reference = this.#references.get(<ModelNode>currentTarget);\r\n            if (reference) {\r\n                const {options} = reference;\r\n                const {properties, propertiesFilter, childList, subtree} = options;\r\n                if (subtree) {\r\n                    if (properties && target instanceof ModelNode) {\r\n                        if (propertiesFilter) {\r\n                            this.#records.push(\r\n                                ...target.getRecords()\r\n                                    .filter(record_i => {\r\n                                        const {propertyName} = record_i;\r\n                                        return propertiesFilter.includes(\r\n                                            propertyName!\r\n                                        )\r\n                                    })\r\n                            );\r\n                        }\r\n                        else {\r\n                            this.#records.push(\r\n                                ...target.getRecords()\r\n                            );\r\n                        }\r\n                        this.#trigger();\r\n                    }\r\n                    else if (childList && target instanceof ModelList) {\r\n                        this.#records.push(\r\n                            ...target.getRecords()\r\n                        );\r\n                        this.#trigger();\r\n                    }\r\n                }\r\n                else if (target == currentTarget) {\r\n                    if (properties && target instanceof ModelNode) {\r\n                        if (propertiesFilter) {\r\n                            this.#records.push(\r\n                                ...target.getRecords()\r\n                                    .filter(record_i => {\r\n                                        const {propertyName} = record_i;\r\n                                        return propertiesFilter.includes(\r\n                                            propertyName!\r\n                                        )\r\n                                    })\r\n                            );\r\n                        }\r\n                        else {\r\n                            this.#records.push(\r\n                                ...target.getRecords()\r\n                            );\r\n                        }\r\n                        this.#trigger();\r\n                    }\r\n                    else if (childList && target instanceof ModelList) {\r\n                        this.#records.push(\r\n                            ...target.getRecords()\r\n                        );\r\n                        this.#trigger();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvar ModelChangeObserver: ModelChangeObserverConstructor = ModelChangeObserverBase;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import { ModelList, ModelNode, ModelChangeRecord, ModelChangeObserver, ModelChangeObserverOptions } from \"../models/Model\";\r\nimport { camelToTrain } from \"./Snippets\";\r\n\r\nexport { CustomElement };\r\nexport { ReactiveChildElements };\r\nexport { QueryProperty };\r\nexport { QueryAllProperty };\r\nexport { AttributeProperty };\r\nexport { reactiveElement };\r\nexport { revokeReactiveElement };\r\nexport { reactiveChildElements };\r\nexport { revokeReactiveChildElements };\r\nexport { element };\r\nexport { fragment };\r\nexport { textNode };\r\nexport { AttributeMutationMixin };\r\nexport { AttributeType };\r\nexport { areAttributesMatching };\r\nexport { AttributeMutationMixinBase };\r\nexport { trimMultilineIndent };\r\nexport { Stylesheet };\r\n\r\nexport { reactiveElementsMap };\r\n\r\ninterface AttributePropertyDecorator {\r\n    (\r\n        init: {\r\n            type: typeof String;\r\n            observed?: boolean;\r\n            defaultValue?: string | null;\r\n            name?: string;\r\n        }\r\n    ): <E extends HTMLElement>(target: E, property: keyof E) => void;\r\n    (\r\n        init: {\r\n            type: typeof Number;\r\n            observed?: boolean;\r\n            defaultValue?: number | null;\r\n            name?: string;\r\n        }\r\n    ): <E extends HTMLElement>(target: E, property: keyof E) => void;\r\n    (\r\n        init: {\r\n            type: typeof Boolean;\r\n            observed?: boolean;\r\n            name?: string;\r\n        }\r\n    ): <E extends HTMLElement>(target: E, property: keyof E) => void;\r\n    (\r\n        init: {\r\n            type: typeof Object;\r\n            observed?: boolean;\r\n            defaultValue?: any | null;\r\n            name?: string;\r\n        }\r\n    ): <E extends HTMLElement>(target: E, property: keyof E) => void;\r\n}\r\n\r\nconst AttributeProperty: AttributePropertyDecorator = function(\r\n    init: {\r\n        type: typeof String | typeof Number | typeof Boolean | typeof Object;\r\n        observed?: boolean;\r\n        defaultValue?: string | number | any | null;\r\n        name?: string;\r\n    }\r\n) {\r\n    return <E extends HTMLElement>(\r\n        target: E, property: keyof E\r\n    ) => {\r\n        const {constructor} = target;\r\n        const {prototype} = constructor;\r\n        const propertyName = String(property);\r\n        const {defaultValue = null, observed = false, name = camelToTrain(propertyName)} = init;\r\n        if (observed) {\r\n            const observedAttributes = Reflect.get(constructor, \"observedAttributes\", constructor);\r\n            if (Array.isArray(observedAttributes)) {\r\n                observedAttributes.push(name);\r\n            }\r\n            else {\r\n                Object.defineProperty(\r\n                    constructor, \"observedAttributes\", {\r\n                        value: [name],\r\n                        writable: false\r\n                    }\r\n                );\r\n            }\r\n        }\r\n        const {type} = init;\r\n        switch (type) {\r\n            case Boolean: {\r\n                Object.defineProperty(prototype, propertyName, {\r\n                    get: function(this: HTMLElement) {\r\n                        return this.hasAttribute(name);\r\n                    },\r\n                    set: function(this: HTMLElement, value) {\r\n                        if (value) {\r\n                            this.setAttribute(name, \"\");\r\n                        }\r\n                        else {\r\n                            this.removeAttribute(name);\r\n                        }\r\n                    }\r\n                });\r\n                break;\r\n            }\r\n            case Object: {\r\n                Object.defineProperty(prototype, propertyName, {\r\n                    get: function(this: HTMLElement) {\r\n                        const val = this.getAttribute(name);\r\n                        return (val !== null) ? JSON.parse(val) : defaultValue;\r\n                    },\r\n                    set: function(this: HTMLElement, value) {\r\n                        if (value !== null) {\r\n                            this.setAttribute(name, JSON.stringify(value));\r\n                        }\r\n                        else {\r\n                            this.removeAttribute(name);\r\n                        }\r\n                    }\r\n                });\r\n                break;\r\n            }\r\n            case Number: {\r\n                Object.defineProperty(prototype, propertyName, {\r\n                    get: function(this: HTMLElement) {\r\n                        const val = this.getAttribute(name);\r\n                        return (val !== null) ? parseFloat(val) : defaultValue;\r\n                    },\r\n                    set: function(this: HTMLElement, value) {\r\n                        if (value !== null) {\r\n                            this.setAttribute(name, value);\r\n                        }\r\n                        else {\r\n                            this.removeAttribute(name);\r\n                        }\r\n                    }\r\n                });\r\n                break;\r\n            }\r\n            case String:\r\n            default: {\r\n                Object.defineProperty(prototype, propertyName, {\r\n                    get: function(this: HTMLElement) {\r\n                        const val = this.getAttribute(name);\r\n                        return (val !== null) ? val : defaultValue;\r\n                    },\r\n                    set: function(this: HTMLElement, value) {\r\n                        if (value !== null) {\r\n                            this.setAttribute(name, value);\r\n                        }\r\n                        else {\r\n                            this.removeAttribute(name);\r\n                        }\r\n                    }\r\n                });\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n    \r\nfunction Stylesheet(text: string): CSSStyleSheet {\r\n    const stylesheet = new CSSStyleSheet();\r\n    (stylesheet as any).replaceSync(text);\r\n    return stylesheet;\r\n}\r\n\r\nfunction trimMultilineIndent(text: string): string {\r\n    const newlineIndex = text.indexOf(\"\\n\");\r\n    text = text.substring(newlineIndex + 1);\r\n    const indentMatch = text.match(/^[\\s]*/);\r\n    if (indentMatch) {\r\n        const indent = text.substring(0, indentMatch[0].length);\r\n        text = text.replaceAll(indent, \"\").trimEnd();\r\n    }\r\n    return text;\r\n}\r\n\r\ninterface CustomElementDecorator {\r\n    (init: {\r\n        name: string;\r\n        options?: ElementDefinitionOptions\r\n    }): <C extends CustomElementConstructor>(elementCtor: C) => C;\r\n}\r\n\r\nconst CustomElement: CustomElementDecorator = function(init: {\r\n    name: string;\r\n    options?: ElementDefinitionOptions\r\n}) {\r\n    return <C extends CustomElementConstructor>(\r\n        elementCtor: C\r\n    ) => {\r\n        const {name, options} = init;\r\n        if (!customElements.get(name)) {\r\n            customElements.define(\r\n                name,\r\n                elementCtor,\r\n                options\r\n            );\r\n        }\r\n        return elementCtor;\r\n    }\r\n}\r\n\r\ninterface QueryPropertyDecorator {\r\n    (\r\n        init: {\r\n            selector: string;\r\n            withinShadowRoot?: boolean;\r\n        }\r\n    ): <E extends HTMLElement>(target: E, propertyKey: keyof E) => void;\r\n}\r\n\r\nconst QueryProperty: QueryPropertyDecorator = function(\r\n        init: {\r\n            selector: string;\r\n            withinShadowRoot?: boolean;\r\n        }\r\n    ) {\r\n    return <E extends HTMLElement>(\r\n        target: E, propertyKey: keyof E\r\n    ) => {\r\n        const {constructor} = target;\r\n        const {prototype} = constructor;\r\n        const propertyName = String(propertyKey);\r\n        const {selector} = init;\r\n        const withinShadowRoot = init.withinShadowRoot ?? false;\r\n        const getter = withinShadowRoot ? function(this: HTMLElement) {\r\n            return this.shadowRoot!.querySelector(selector);\r\n        } : function(this: HTMLElement) {\r\n            return this.querySelector(selector);\r\n        }\r\n        Object.defineProperty(prototype, propertyName, {\r\n            get: getter\r\n        });\r\n    }\r\n}\r\n\r\ninterface QueryAllPropertyDecorator {\r\n    (\r\n        init: {\r\n            selector: string;\r\n            withinShadowRoot?: boolean;\r\n        }\r\n    ): <E extends HTMLElement>(target: E, propertyKey: keyof E) => void;\r\n}\r\n\r\nconst QueryAllProperty: QueryAllPropertyDecorator = function(\r\n        init: {\r\n            selector: string;\r\n            withinShadowRoot?: boolean;\r\n        }\r\n    ) {\r\n    return <E extends HTMLElement>(\r\n        target: E, propertyKey: keyof E\r\n    ) => {\r\n        const {constructor} = target;\r\n        const {prototype} = constructor;\r\n        const propertyName = String(propertyKey);\r\n        const {selector} = init;\r\n        const withinShadowRoot = init.withinShadowRoot ?? false;\r\n        const getter = withinShadowRoot ? function(this: HTMLElement) {\r\n            return Array.from(this.shadowRoot!.querySelectorAll(selector));\r\n        } : function(this: HTMLElement) {\r\n            return Array.from(this.querySelectorAll(selector));\r\n        };\r\n        Object.defineProperty(prototype, propertyName, {\r\n            get: getter\r\n        });\r\n    }\r\n}\r\n\r\nfunction fragment(...nodes: (Node | string)[]): DocumentFragment {\r\n    const fragment = document.createDocumentFragment();\r\n    fragment.append(...nodes);\r\n    return fragment;\r\n}\r\n\r\nfunction textNode(text: string): Node {\r\n    return document.createTextNode(text);\r\n}\r\n\r\ninterface HTMLElementInit {\r\n    options?: ElementCreationOptions,\r\n    attributes?: {\r\n        [name: string]: number | string | boolean | undefined\r\n    },\r\n    dataset?: {\r\n        [property: string]: string | number | boolean\r\n    },\r\n    children?: Node | string | (Node | string)[] | NodeList | ReactiveChildElements,\r\n    listeners?: {\r\n        [EventName in keyof HTMLElementEventMap]?: EventListenerOrEventListenerObject | [EventListenerOrEventListenerObject, boolean | AddEventListenerOptions | undefined]\r\n    }\r\n}\r\n\r\nfunction element<E extends HTMLElementTagNameMap[K], K extends keyof HTMLElementTagNameMap>(\r\n    tagName: K, init?: HTMLElementInit): E;\r\nfunction element(\r\n    tagName: string, init?: HTMLElementInit): HTMLElement;\r\nfunction element<K extends keyof HTMLElementTagNameMap>(\r\n    tagName: K, init?: HTMLElementInit): HTMLElementTagNameMap[K] {\r\n    if (init) {\r\n        const {options, attributes, dataset, children, listeners} = init;\r\n        const element = document.createElement(tagName, options);\r\n        if (attributes) {\r\n            Object.entries(attributes).forEach(([attributeName, attributeValue]) => {\r\n                if (attributeValue !== undefined) {\r\n                    if (typeof attributeValue === \"boolean\") {\r\n                        element.toggleAttribute(camelToTrain(attributeName), attributeValue);\r\n                    }\r\n                    else {\r\n                        element.setAttribute(camelToTrain(attributeName), String(attributeValue));\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        if (dataset) {\r\n            const {dataset: elementDataset} = element;\r\n            Object.keys(dataset).forEach((datasetEntry_i) => {\r\n                elementDataset[datasetEntry_i] = String(dataset[datasetEntry_i]);\r\n            });\r\n        }\r\n        if (children) {\r\n            if (typeof children === \"function\") {\r\n                children(element);\r\n            }\r\n            else if (typeof children === \"object\" && \"length\" in children) {\r\n                element.append(...Array.from(children));\r\n            }\r\n            else {\r\n                element.append(children);\r\n            }\r\n        }\r\n        if (listeners) {\r\n            Object.entries(listeners).forEach(([name_i, listener_i]) => {\r\n                if (Array.isArray(listener_i)) {\r\n                    element.addEventListener(name_i, listener_i[0], listener_i[1]);\r\n                }\r\n                else {\r\n                    element.addEventListener(name_i, listener_i);\r\n                }\r\n            });\r\n        }\r\n        return element;\r\n    }\r\n    return document.createElement(tagName);\r\n}\r\n\r\nconst reactiveElementsMap = new WeakMap<ModelNode, {\r\n    observerOptions: ModelChangeObserverOptions,\r\n    reactiveElementsArray: {\r\n        elementRef: WeakRef<Element>,\r\n        properties: string[],\r\n        react: (element: any, property: string, oldValue: any, newValue: any) => void;\r\n    }[]\r\n}>();\r\n\r\nconst reactiveElementsFinalizationRegistry = new FinalizationRegistry((heldValue: {\r\n    model: ModelNode,\r\n    reactiveElement: {\r\n        elementRef: WeakRef<Element>,\r\n        properties: string[],\r\n        react: (element: any, property: string, oldValue: any, newValue: any) => void;\r\n    }\r\n}) => {\r\n    const {model, reactiveElement} = heldValue;\r\n    const reactiveElementsMapEntry = reactiveElementsMap.get(model);\r\n    if (reactiveElementsMapEntry !== undefined) {\r\n        const {reactiveElementsArray} = reactiveElementsMapEntry;\r\n        reactiveElementsArray.splice(reactiveElementsArray.indexOf(reactiveElement), 1);\r\n    }\r\n});\r\n\r\nconst reactiveElementsPropertyObserver = new ModelChangeObserver((records: ModelChangeRecord[]) => {\r\n    records.forEach((record_i) => {\r\n        const {target, propertyName, oldValue, newValue} = record_i;\r\n        const {reactiveElementsArray} = reactiveElementsMap.get(target)!;\r\n        reactiveElementsArray.forEach(reactiveElement_i => {\r\n            const {elementRef, react, properties} = reactiveElement_i;\r\n            const element = elementRef.deref();\r\n            if (element) {\r\n                if (properties.includes(propertyName!)) {\r\n                    react(element, propertyName!, oldValue, newValue);\r\n                }\r\n            }\r\n        });\r\n    });\r\n});\r\n\r\nfunction reactiveElement<M extends ModelNode, E extends Element, K extends string>(\r\n    model: M,\r\n    element: E,\r\n    properties: K[],\r\n    react: (object: E, property: K, oldValue: any, newValue: any) => void\r\n): E;\r\nfunction reactiveElement<M extends ModelNode, E extends Element>(\r\n    model: M,\r\n    element: E,\r\n    properties: string[],\r\n    react: (element: E, property: string, oldValue: any, newValue: any) => void\r\n): E {\r\n    const elementRef = new WeakRef(element);\r\n    const reactiveElement = {elementRef, react, properties};\r\n    const reactiveElementsMapEntry = reactiveElementsMap.get(model);\r\n    reactiveElementsFinalizationRegistry.register(element, {model, reactiveElement});\r\n    if (!reactiveElementsMapEntry) {\r\n        const observerOptions = {\r\n            properties: true,\r\n            propertiesFilter: properties\r\n        };\r\n        const reactiveElementsArray = [reactiveElement];\r\n        reactiveElementsMap.set(model, {observerOptions, reactiveElementsArray});\r\n        reactiveElementsPropertyObserver.observe(model, observerOptions);\r\n    }\r\n    else {\r\n        const {reactiveElementsArray, observerOptions} = reactiveElementsMapEntry;\r\n        const {propertiesFilter} = observerOptions;\r\n        reactiveElementsArray.push(reactiveElement);\r\n        observerOptions.propertiesFilter = propertiesFilter ?\r\n            propertiesFilter.concat(properties.filter(\r\n                property_i => !propertiesFilter.includes(property_i)\r\n            )) : properties.filter(\r\n                (property_i, i, properties) => properties.indexOf(property_i) === i\r\n            )\r\n    }\r\n    properties.forEach((property_i) => {\r\n        if (property_i in model) {\r\n            const value = Reflect.get(model, property_i, model);\r\n            react(element, <any>property_i, <any>undefined, value);\r\n        }\r\n    });\r\n    return element;\r\n}\r\n\r\nfunction revokeReactiveElement<M extends ModelNode, E extends Element>(\r\n    model: M,\r\n    element: E\r\n): void {\r\n    const reactiveElementsMapEntry = reactiveElementsMap.get(model);\r\n    if (reactiveElementsMapEntry) {\r\n        const {reactiveElementsArray} = reactiveElementsMapEntry;\r\n        const reactiveElementIndex = reactiveElementsArray.findIndex(\r\n            reactiveElement => reactiveElement.elementRef.deref() === element\r\n        );\r\n        if (reactiveElementIndex > -1) {\r\n            reactiveElementsArray.splice(reactiveElementIndex, 1);\r\n        }\r\n        if (reactiveElementsArray.length === 0) {\r\n            reactiveElementsMap.delete(model);\r\n        }\r\n    }\r\n}\r\n\r\ninterface ReactiveChildElements {\r\n    (parent: ParentNode): void;\r\n}\r\n\r\nconst reactiveChildElementsMap = new WeakMap<ModelList, {\r\n    reactiveChildElementsArray: {\r\n        parentRef: WeakRef<ParentNode>,\r\n        mapping: (item: any) => Element,\r\n        placeholder?: Element\r\n    }[]\r\n}>();\r\n\r\nconst reactiveChildElementsFinalizationRegistry = new FinalizationRegistry((heldValue: {\r\n    list: ModelList,\r\n    reactiveChildElement: {\r\n        parentRef: WeakRef<ParentNode>,\r\n        mapping: (item: any) => Element,\r\n        placeholder?: Element\r\n    }\r\n}) => {\r\n    const {list, reactiveChildElement} = heldValue;\r\n    const reactiveChildrenElementsMapEntry = reactiveChildElementsMap.get(list);\r\n    if (reactiveChildrenElementsMapEntry) {\r\n        const {reactiveChildElementsArray} = reactiveChildrenElementsMapEntry;\r\n        reactiveChildElementsArray.splice(reactiveChildElementsArray.indexOf(reactiveChildElement), 1);\r\n    }\r\n});\r\n\r\nconst reactiveChildElementsObserver = new ModelChangeObserver((records: ModelChangeRecord[]) => {\r\n    let range: null | Range = null;\r\n    Array.from(records.values()).forEach((record_i) => {\r\n        const {target} = record_i;\r\n        const list = <ModelList>target;\r\n        const {length: listLength} = list;\r\n        const {reactiveChildElementsArray} = reactiveChildElementsMap.get(list)!;\r\n        reactiveChildElementsArray.forEach((reactiveChildElements_i) => {\r\n            const {parentRef, mapping, placeholder} = reactiveChildElements_i;\r\n            const parent = parentRef.deref();\r\n            if (parent) {\r\n                const {firstChild, children} = parent;\r\n                const {length: childrenCount} = children;\r\n                if (placeholder && listLength > 0 && firstChild == placeholder) {\r\n                    parent.removeChild(placeholder);\r\n                }\r\n                const {changeType, LIST_INSERT, LIST_REMOVE, LIST_SORT} = record_i;\r\n                switch (changeType) {\r\n                    case LIST_INSERT: {\r\n                        const {insertedIndex, insertedItems} = record_i;\r\n                        const insertedItemsArray = Array.from(insertedItems.values()).map(mapping);\r\n                        const {length: childrenCount} = children;\r\n                        if (insertedIndex < childrenCount) {\r\n                            children[insertedIndex].before(...insertedItemsArray);\r\n                        }\r\n                        else {\r\n                            parent.append(...insertedItemsArray);\r\n                        }\r\n                        break;\r\n                    }\r\n                    case LIST_REMOVE: {\r\n                        const {removedIndex, removedItems} = record_i;\r\n                        const {length: removedCount} = removedItems;\r\n                        range = range ?? document.createRange();\r\n                        const removeEndIndex = removedIndex + (removedCount - 1);\r\n                        if (removeEndIndex < childrenCount) {\r\n                            range.setStartBefore(children[removedIndex]);\r\n                            range.setEndAfter(children[removeEndIndex]);\r\n                            range.deleteContents();\r\n                        }\r\n                        break;\r\n                    }\r\n                    case LIST_SORT: {\r\n                        const {sortedIndices} = record_i;\r\n                        const childrenArray = Array.from(children);\r\n                        parent.append(\r\n                            ...sortedIndices.filter(\r\n                                index_i => index_i < childrenCount\r\n                            ).map(\r\n                                index_i => childrenArray[index_i]\r\n                            )\r\n                        );\r\n                        break;\r\n                    }\r\n                }\r\n                if (listLength == 0 && placeholder) {\r\n                    parent.append(placeholder);\r\n                }\r\n            }\r\n        });\r\n    });\r\n});\r\n\r\nfunction reactiveChildElements<Model extends ModelNode>(\r\n    list: ModelList<Model>,\r\n    mapping: (item: Model) => Element,\r\n    placeholder?: Element\r\n): ReactiveChildElements {\r\n    return (parent: ParentNode) => {\r\n        const parentRef = new WeakRef(parent);\r\n        const reactiveChildElementsMapEntry = reactiveChildElementsMap.get(list);\r\n        const reactiveChildElement = {parentRef, mapping, placeholder};\r\n        reactiveChildElementsFinalizationRegistry.register(parent, {list, reactiveChildElement});\r\n        if (!reactiveChildElementsMapEntry) {\r\n            const reactiveChildElementsArray = [reactiveChildElement];\r\n            reactiveChildElementsMap.set(list, {reactiveChildElementsArray});\r\n            reactiveChildElementsObserver.observe(list, {\r\n                childList: true\r\n            });\r\n        }\r\n        else {\r\n            const {reactiveChildElementsArray} = reactiveChildElementsMapEntry;\r\n            reactiveChildElementsArray.push(reactiveChildElement);\r\n        }\r\n        const children = list.length == 0 && placeholder ?\r\n            [placeholder] : Array.from(list.values()).map(mapping);\r\n        parent.replaceChildren(...children);\r\n    }\r\n}\r\n\r\nfunction revokeReactiveChildElements<Model extends ModelNode>(\r\n    list: ModelList<Model>,\r\n    parent: ParentNode,\r\n): void {\r\n    const reactiveChildElementsMapEntry = reactiveChildElementsMap.get(list);\r\n    if (reactiveChildElementsMapEntry) {\r\n        const {reactiveChildElementsArray} = reactiveChildElementsMapEntry;\r\n        const reactiveChildElementsIndex = reactiveChildElementsArray.findIndex(\r\n            reactiveChildElement => reactiveChildElement.parentRef.deref() === parent\r\n        );\r\n        if (reactiveChildElementsIndex > -1) {\r\n            reactiveChildElementsArray.splice(reactiveChildElementsIndex, 1);\r\n        }\r\n        if (reactiveChildElementsArray.length === 0) {\r\n            reactiveChildElementsMap.delete(list);\r\n        }\r\n    }\r\n}\r\n\r\ninterface AttributeMutationMixin {\r\n    readonly attributeName: string;\r\n    readonly attributeValue: string;\r\n    readonly attributeType: AttributeType;\r\n    attach(element: Element): void;\r\n    detach(element: Element): void;\r\n}\r\n\r\ntype AttributeType = \"string\" | \"boolean\" | \"list\";\r\n\r\nfunction areAttributesMatching(\r\n    referenceAttributeType: AttributeType,\r\n    referenceAttributeName: string, referenceAttributeValue: string,\r\n    attributeName: string, attributeValue: string | null): boolean {\r\n    if (referenceAttributeName == attributeName) {\r\n        switch (referenceAttributeType) {\r\n            case \"boolean\":\r\n                return referenceAttributeValue == \"\" && attributeValue == \"\";\r\n            case \"string\":\r\n                return referenceAttributeValue !== \"\" && (referenceAttributeValue == attributeValue);\r\n            case \"list\":\r\n                return (referenceAttributeValue !== \"\" && attributeValue !== null) && new RegExp(`${referenceAttributeValue}\\s*?`, \"g\").test(attributeValue );\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nclass AttributeMutationMixinBase implements AttributeMutationMixin {\r\n    readonly attributeName: string;\r\n    readonly attributeValue: string;\r\n    readonly attributeType: AttributeType;\r\n\r\n    constructor(attributeName: string, attributeType: AttributeType = \"boolean\", attributeValue: string = \"\") {\r\n        this.attributeName = attributeName;\r\n        this.attributeType = attributeType;\r\n        this.attributeValue = attributeValue;\r\n    }\r\n\r\n    attach(): void {\r\n        throw new TypeError(\"Not implemented method.\");\r\n    }\r\n\r\n    detach(): void {\r\n        throw new TypeError(\"Not implemented method.\");\r\n    }\r\n}"],"names":["camelToTrain","str","replace","toLowerCase","ModelChangeRecordBase","constructor","init","this","target","changeType","propertyName","oldValue","undefined","newValue","removedIndex","removedItems","ModelNodesList","insertedIndex","insertedItems","sortedIndices","PROPERTY_CHANGE","LIST_REMOVE","LIST_INSERT","LIST_SORT","ModelChangeRecord","items","slice","length","item","index","values","ModelEventBase","type","currentTarget","ModelEventTargetAccessor","setCurrentTarget","event","setTarget","ModelEvent","ModelEventTargetBase","Map","receiveEvent","callbacks","get","forEach","callback_i","addEventListener","callback","push","set","removeEventListener","callbackIndex","findIndex","splice","delete","dispatchEvent","ModelNodeBase","super","parentNode","setParent","isCyclicReference","ancestorNode","TypeError","beginChanges","endChanges","getRecords","property","records","record","ModelNodeRecordsAccessor","triggerChange","node","handleRecord","ModelNode","ModelObjectBase","ModelObjectPropertiesAccessor","setProperty","value","getProperty","ModelList","item_i","indexOf","sort","compareFunction","indexedItems","map","i","indexedItem_a","indexedItem_b","indexedItem_i","prepend","_items","append","insert","Math","abs","remove","clear","removedItem_i","reference","options","properties","propertiesFilter","childList","subtree","filter","record_i","includes","ModelChangeObserver","WeakMap","observe","references","listener","bind","unobserve","disconnect","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","obj","prop","prototype","hasOwnProperty","call","AttributeProperty","String","defaultValue","observed","name","observedAttributes","Reflect","Array","isArray","writable","Boolean","hasAttribute","setAttribute","removeAttribute","val","getAttribute","JSON","parse","stringify","Number","parseFloat","Stylesheet","text","stylesheet","CSSStyleSheet","replaceSync","trimMultilineIndent","newlineIndex","indentMatch","substring","match","indent","replaceAll","trimEnd","CustomElement","elementCtor","customElements","define","QueryProperty","propertyKey","selector","getter","withinShadowRoot","shadowRoot","querySelector","QueryAllProperty","from","querySelectorAll","fragment","nodes","document","createDocumentFragment","textNode","createTextNode","element","tagName","attributes","dataset","children","listeners","createElement","entries","attributeName","attributeValue","toggleAttribute","elementDataset","keys","datasetEntry_i","name_i","listener_i","reactiveElementsMap","reactiveElementsFinalizationRegistry","FinalizationRegistry","heldValue","model","reactiveElement","reactiveElementsMapEntry","reactiveElementsArray","reactiveElementsPropertyObserver","reactiveElement_i","elementRef","react","deref","WeakRef","register","observerOptions","concat","property_i","revokeReactiveElement","reactiveElementIndex","reactiveChildElementsMap","reactiveChildElementsFinalizationRegistry","list","reactiveChildElement","reactiveChildrenElementsMapEntry","reactiveChildElementsArray","reactiveChildElementsObserver","range","listLength","reactiveChildElements_i","parentRef","mapping","placeholder","parent","firstChild","childrenCount","removeChild","insertedItemsArray","before","removedCount","createRange","removeEndIndex","setStartBefore","setEndAfter","deleteContents","childrenArray","index_i","reactiveChildElements","reactiveChildElementsMapEntry","replaceChildren","revokeReactiveChildElements","reactiveChildElementsIndex","areAttributesMatching","referenceAttributeType","referenceAttributeName","referenceAttributeValue","RegExp","test","AttributeMutationMixinBase","attributeType","attach","detach"],"sourceRoot":""}