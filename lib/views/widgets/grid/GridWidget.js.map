{"version":3,"file":"views/widgets/grid/GridWidget.js","mappings":"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","sources":["webpack://editor/./src/elements/Element.ts","webpack://editor/./src/elements/Snippets.ts","webpack://editor/./src/models/Model.ts","webpack://editor/./src/views/widgets/Widget.ts","webpack://editor/./src/views/widgets/grid/GridCellWidget.ts","webpack://editor/./src/views/widgets/grid/GridRowWidget.ts","webpack://editor/webpack/bootstrap","webpack://editor/webpack/runtime/define property getters","webpack://editor/webpack/runtime/hasOwnProperty shorthand","webpack://editor/./src/views/widgets/grid/GridWidget.ts"],"sourcesContent":["import { ModelList, ModelNode, ModelChangeRecord, ModelChangeObserver, ModelChangeObserverOptions } from \"../models/Model\";\r\nimport { camelToTrain } from \"./Snippets\";\r\n\r\nexport { CustomElement };\r\nexport { ReactiveChildElements };\r\nexport { QueryProperty };\r\nexport { QueryAllProperty };\r\nexport { AttributeProperty };\r\nexport { reactiveElement };\r\nexport { revokeReactiveElement };\r\nexport { reactiveChildElements };\r\nexport { revokeReactiveChildElements };\r\nexport { element };\r\nexport { fragment };\r\nexport { textNode };\r\nexport { AttributeMutationMixin };\r\nexport { AttributeType };\r\nexport { areAttributesMatching };\r\nexport { AttributeMutationMixinBase };\r\nexport { trimMultilineIndent };\r\nexport { Stylesheet };\r\n\r\nexport { reactiveElementsMap };\r\n\r\ninterface AttributePropertyDecorator {\r\n    (\r\n        init: {\r\n            type: typeof String;\r\n            observed?: boolean;\r\n            defaultValue?: string | null;\r\n            name?: string;\r\n        }\r\n    ): <E extends HTMLElement>(target: E, property: keyof E) => void;\r\n    (\r\n        init: {\r\n            type: typeof Number;\r\n            observed?: boolean;\r\n            defaultValue?: number | null;\r\n            name?: string;\r\n        }\r\n    ): <E extends HTMLElement>(target: E, property: keyof E) => void;\r\n    (\r\n        init: {\r\n            type: typeof Boolean;\r\n            observed?: boolean;\r\n            name?: string;\r\n        }\r\n    ): <E extends HTMLElement>(target: E, property: keyof E) => void;\r\n    (\r\n        init: {\r\n            type: typeof Object;\r\n            observed?: boolean;\r\n            defaultValue?: any | null;\r\n            name?: string;\r\n        }\r\n    ): <E extends HTMLElement>(target: E, property: keyof E) => void;\r\n}\r\n\r\nconst AttributeProperty: AttributePropertyDecorator = function(\r\n    init: {\r\n        type: typeof String | typeof Number | typeof Boolean | typeof Object;\r\n        observed?: boolean;\r\n        defaultValue?: string | number | any | null;\r\n        name?: string;\r\n    }\r\n) {\r\n    return <E extends HTMLElement>(\r\n        target: E, property: keyof E\r\n    ) => {\r\n        const {constructor} = target;\r\n        const {prototype} = constructor;\r\n        const propertyName = String(property);\r\n        const {defaultValue = null, observed = false, name = camelToTrain(propertyName)} = init;\r\n        if (observed) {\r\n            const observedAttributes = Reflect.get(constructor, \"observedAttributes\", constructor);\r\n            if (Array.isArray(observedAttributes)) {\r\n                observedAttributes.push(name);\r\n            }\r\n            else {\r\n                Object.defineProperty(\r\n                    constructor, \"observedAttributes\", {\r\n                        value: [name],\r\n                        writable: false\r\n                    }\r\n                );\r\n            }\r\n        }\r\n        const {type} = init;\r\n        switch (type) {\r\n            case Boolean: {\r\n                Object.defineProperty(prototype, propertyName, {\r\n                    get: function(this: HTMLElement) {\r\n                        return this.hasAttribute(name);\r\n                    },\r\n                    set: function(this: HTMLElement, value) {\r\n                        if (value) {\r\n                            this.setAttribute(name, \"\");\r\n                        }\r\n                        else {\r\n                            this.removeAttribute(name);\r\n                        }\r\n                    }\r\n                });\r\n                break;\r\n            }\r\n            case Object: {\r\n                Object.defineProperty(prototype, propertyName, {\r\n                    get: function(this: HTMLElement) {\r\n                        const val = this.getAttribute(name);\r\n                        return (val !== null) ? JSON.parse(val) : defaultValue;\r\n                    },\r\n                    set: function(this: HTMLElement, value) {\r\n                        if (value !== null) {\r\n                            this.setAttribute(name, JSON.stringify(value));\r\n                        }\r\n                        else {\r\n                            this.removeAttribute(name);\r\n                        }\r\n                    }\r\n                });\r\n                break;\r\n            }\r\n            case Number: {\r\n                Object.defineProperty(prototype, propertyName, {\r\n                    get: function(this: HTMLElement) {\r\n                        const val = this.getAttribute(name);\r\n                        return (val !== null) ? parseFloat(val) : defaultValue;\r\n                    },\r\n                    set: function(this: HTMLElement, value) {\r\n                        if (value !== null) {\r\n                            this.setAttribute(name, value);\r\n                        }\r\n                        else {\r\n                            this.removeAttribute(name);\r\n                        }\r\n                    }\r\n                });\r\n                break;\r\n            }\r\n            case String:\r\n            default: {\r\n                Object.defineProperty(prototype, propertyName, {\r\n                    get: function(this: HTMLElement) {\r\n                        const val = this.getAttribute(name);\r\n                        return (val !== null) ? val : defaultValue;\r\n                    },\r\n                    set: function(this: HTMLElement, value) {\r\n                        if (value !== null) {\r\n                            this.setAttribute(name, value);\r\n                        }\r\n                        else {\r\n                            this.removeAttribute(name);\r\n                        }\r\n                    }\r\n                });\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n    \r\nfunction Stylesheet(text: string): CSSStyleSheet {\r\n    const stylesheet = new CSSStyleSheet();\r\n    (stylesheet as any).replaceSync(text);\r\n    return stylesheet;\r\n}\r\n\r\nfunction trimMultilineIndent(text: string): string {\r\n    const newlineIndex = text.indexOf(\"\\n\");\r\n    text = text.substring(newlineIndex + 1);\r\n    const indentMatch = text.match(/^[\\s]*/);\r\n    if (indentMatch) {\r\n        const indent = text.substring(0, indentMatch[0].length);\r\n        text = text.replaceAll(indent, \"\").trimEnd();\r\n    }\r\n    return text;\r\n}\r\n\r\ninterface CustomElementDecorator {\r\n    (init: {\r\n        name: string;\r\n        options?: ElementDefinitionOptions\r\n    }): <C extends CustomElementConstructor>(elementCtor: C) => C;\r\n}\r\n\r\nconst CustomElement: CustomElementDecorator = function(init: {\r\n    name: string;\r\n    options?: ElementDefinitionOptions\r\n}) {\r\n    return <C extends CustomElementConstructor>(\r\n        elementCtor: C\r\n    ) => {\r\n        const {name, options} = init;\r\n        if (!customElements.get(name)) {\r\n            customElements.define(\r\n                name,\r\n                elementCtor,\r\n                options\r\n            );\r\n        }\r\n        return elementCtor;\r\n    }\r\n}\r\n\r\ninterface QueryPropertyDecorator {\r\n    (\r\n        init: {\r\n            selector: string;\r\n            withinShadowRoot?: boolean;\r\n        }\r\n    ): <E extends HTMLElement>(target: E, propertyKey: keyof E) => void;\r\n}\r\n\r\nconst QueryProperty: QueryPropertyDecorator = function(\r\n        init: {\r\n            selector: string;\r\n            withinShadowRoot?: boolean;\r\n        }\r\n    ) {\r\n    return <E extends HTMLElement>(\r\n        target: E, propertyKey: keyof E\r\n    ) => {\r\n        const {constructor} = target;\r\n        const {prototype} = constructor;\r\n        const propertyName = String(propertyKey);\r\n        const {selector} = init;\r\n        const withinShadowRoot = init.withinShadowRoot ?? false;\r\n        const getter = withinShadowRoot ? function(this: HTMLElement) {\r\n            return this.shadowRoot!.querySelector(selector);\r\n        } : function(this: HTMLElement) {\r\n            return this.querySelector(selector);\r\n        }\r\n        Object.defineProperty(prototype, propertyName, {\r\n            get: getter\r\n        });\r\n    }\r\n}\r\n\r\ninterface QueryAllPropertyDecorator {\r\n    (\r\n        init: {\r\n            selector: string;\r\n            withinShadowRoot?: boolean;\r\n        }\r\n    ): <E extends HTMLElement>(target: E, propertyKey: keyof E) => void;\r\n}\r\n\r\nconst QueryAllProperty: QueryAllPropertyDecorator = function(\r\n        init: {\r\n            selector: string;\r\n            withinShadowRoot?: boolean;\r\n        }\r\n    ) {\r\n    return <E extends HTMLElement>(\r\n        target: E, propertyKey: keyof E\r\n    ) => {\r\n        const {constructor} = target;\r\n        const {prototype} = constructor;\r\n        const propertyName = String(propertyKey);\r\n        const {selector} = init;\r\n        const withinShadowRoot = init.withinShadowRoot ?? false;\r\n        const getter = withinShadowRoot ? function(this: HTMLElement) {\r\n            return Array.from(this.shadowRoot!.querySelectorAll(selector));\r\n        } : function(this: HTMLElement) {\r\n            return Array.from(this.querySelectorAll(selector));\r\n        };\r\n        Object.defineProperty(prototype, propertyName, {\r\n            get: getter\r\n        });\r\n    }\r\n}\r\n\r\nfunction fragment(...nodes: (Node | string)[]): DocumentFragment {\r\n    const fragment = document.createDocumentFragment();\r\n    fragment.append(...nodes);\r\n    return fragment;\r\n}\r\n\r\nfunction textNode(text: string): Node {\r\n    return document.createTextNode(text);\r\n}\r\n\r\ninterface HTMLElementInit {\r\n    options?: ElementCreationOptions,\r\n    attributes?: {\r\n        [name: string]: number | string | boolean | undefined\r\n    },\r\n    dataset?: {\r\n        [property: string]: string | number | boolean\r\n    },\r\n    children?: Node | string | (Node | string)[] | NodeList | ReactiveChildElements,\r\n    listeners?: {\r\n        [EventName in keyof HTMLElementEventMap]?: EventListenerOrEventListenerObject | [EventListenerOrEventListenerObject, boolean | AddEventListenerOptions | undefined]\r\n    }\r\n}\r\n\r\nfunction element<E extends HTMLElementTagNameMap[K], K extends keyof HTMLElementTagNameMap>(\r\n    tagName: K, init?: HTMLElementInit): E;\r\nfunction element(\r\n    tagName: string, init?: HTMLElementInit): HTMLElement;\r\nfunction element<K extends keyof HTMLElementTagNameMap>(\r\n    tagName: K, init?: HTMLElementInit): HTMLElementTagNameMap[K] {\r\n    if (init) {\r\n        const {options, attributes, dataset, children, listeners} = init;\r\n        const element = document.createElement(tagName, options);\r\n        if (attributes) {\r\n            Object.entries(attributes).forEach(([attributeName, attributeValue]) => {\r\n                if (attributeValue !== undefined) {\r\n                    if (typeof attributeValue === \"boolean\") {\r\n                        element.toggleAttribute(camelToTrain(attributeName), attributeValue);\r\n                    }\r\n                    else {\r\n                        element.setAttribute(camelToTrain(attributeName), String(attributeValue));\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        if (dataset) {\r\n            const {dataset: elementDataset} = element;\r\n            Object.keys(dataset).forEach((datasetEntry_i) => {\r\n                elementDataset[datasetEntry_i] = String(dataset[datasetEntry_i]);\r\n            });\r\n        }\r\n        if (children) {\r\n            if (typeof children === \"function\") {\r\n                children(element);\r\n            }\r\n            else if (typeof children === \"object\" && \"length\" in children) {\r\n                element.append(...Array.from(children));\r\n            }\r\n            else {\r\n                element.append(children);\r\n            }\r\n        }\r\n        if (listeners) {\r\n            Object.entries(listeners).forEach(([name_i, listener_i]) => {\r\n                if (Array.isArray(listener_i)) {\r\n                    element.addEventListener(name_i, listener_i[0], listener_i[1]);\r\n                }\r\n                else {\r\n                    element.addEventListener(name_i, listener_i);\r\n                }\r\n            });\r\n        }\r\n        return element;\r\n    }\r\n    return document.createElement(tagName);\r\n}\r\n\r\nconst reactiveElementsMap = new WeakMap<ModelNode, {\r\n    observerOptions: ModelChangeObserverOptions,\r\n    reactiveElementsArray: {\r\n        elementRef: WeakRef<Element>,\r\n        properties: string[],\r\n        react: (element: any, property: string, oldValue: any, newValue: any) => void;\r\n    }[]\r\n}>();\r\n\r\nconst reactiveElementsFinalizationRegistry = new FinalizationRegistry((heldValue: {\r\n    model: ModelNode,\r\n    reactiveElement: {\r\n        elementRef: WeakRef<Element>,\r\n        properties: string[],\r\n        react: (element: any, property: string, oldValue: any, newValue: any) => void;\r\n    }\r\n}) => {\r\n    const {model, reactiveElement} = heldValue;\r\n    const reactiveElementsMapEntry = reactiveElementsMap.get(model);\r\n    if (reactiveElementsMapEntry !== undefined) {\r\n        const {reactiveElementsArray} = reactiveElementsMapEntry;\r\n        reactiveElementsArray.splice(reactiveElementsArray.indexOf(reactiveElement), 1);\r\n    }\r\n});\r\n\r\nconst reactiveElementsPropertyObserver = new ModelChangeObserver((records: ModelChangeRecord[]) => {\r\n    records.forEach((record_i) => {\r\n        const {target, propertyName, oldValue, newValue} = record_i;\r\n        const {reactiveElementsArray} = reactiveElementsMap.get(target)!;\r\n        reactiveElementsArray.forEach(reactiveElement_i => {\r\n            const {elementRef, react, properties} = reactiveElement_i;\r\n            const element = elementRef.deref();\r\n            if (element) {\r\n                if (properties.includes(propertyName!)) {\r\n                    react(element, propertyName!, oldValue, newValue);\r\n                }\r\n            }\r\n        });\r\n    });\r\n});\r\n\r\nfunction reactiveElement<M extends ModelNode, E extends Element, K extends string>(\r\n    model: M,\r\n    element: E,\r\n    properties: K[],\r\n    react: (object: E, property: K, oldValue: any, newValue: any) => void\r\n): E;\r\nfunction reactiveElement<M extends ModelNode, E extends Element>(\r\n    model: M,\r\n    element: E,\r\n    properties: string[],\r\n    react: (element: E, property: string, oldValue: any, newValue: any) => void\r\n): E {\r\n    const elementRef = new WeakRef(element);\r\n    const reactiveElement = {elementRef, react, properties};\r\n    const reactiveElementsMapEntry = reactiveElementsMap.get(model);\r\n    reactiveElementsFinalizationRegistry.register(element, {model, reactiveElement});\r\n    if (!reactiveElementsMapEntry) {\r\n        const observerOptions = {\r\n            properties: true,\r\n            propertiesFilter: properties\r\n        };\r\n        const reactiveElementsArray = [reactiveElement];\r\n        reactiveElementsMap.set(model, {observerOptions, reactiveElementsArray});\r\n        reactiveElementsPropertyObserver.observe(model, observerOptions);\r\n    }\r\n    else {\r\n        const {reactiveElementsArray, observerOptions} = reactiveElementsMapEntry;\r\n        const {propertiesFilter} = observerOptions;\r\n        reactiveElementsArray.push(reactiveElement);\r\n        observerOptions.propertiesFilter = propertiesFilter ?\r\n            propertiesFilter.concat(properties.filter(\r\n                property_i => !propertiesFilter.includes(property_i)\r\n            )) : properties.filter(\r\n                (property_i, i, properties) => properties.indexOf(property_i) === i\r\n            )\r\n    }\r\n    properties.forEach((property_i) => {\r\n        if (property_i in model) {\r\n            const value = Reflect.get(model, property_i, model);\r\n            react(element, <any>property_i, <any>undefined, value);\r\n        }\r\n    });\r\n    return element;\r\n}\r\n\r\nfunction revokeReactiveElement<M extends ModelNode, E extends Element>(\r\n    model: M,\r\n    element: E\r\n): void {\r\n    const reactiveElementsMapEntry = reactiveElementsMap.get(model);\r\n    if (reactiveElementsMapEntry) {\r\n        const {reactiveElementsArray} = reactiveElementsMapEntry;\r\n        const reactiveElementIndex = reactiveElementsArray.findIndex(\r\n            reactiveElement => reactiveElement.elementRef.deref() === element\r\n        );\r\n        if (reactiveElementIndex > -1) {\r\n            reactiveElementsArray.splice(reactiveElementIndex, 1);\r\n        }\r\n        if (reactiveElementsArray.length === 0) {\r\n            reactiveElementsMap.delete(model);\r\n        }\r\n    }\r\n}\r\n\r\ninterface ReactiveChildElements {\r\n    (parent: ParentNode): void;\r\n}\r\n\r\nconst reactiveChildElementsMap = new WeakMap<ModelList, {\r\n    reactiveChildElementsArray: {\r\n        parentRef: WeakRef<ParentNode>,\r\n        mapping: (item: any) => Element,\r\n        placeholder?: Element\r\n    }[]\r\n}>();\r\n\r\nconst reactiveChildElementsFinalizationRegistry = new FinalizationRegistry((heldValue: {\r\n    list: ModelList,\r\n    reactiveChildElement: {\r\n        parentRef: WeakRef<ParentNode>,\r\n        mapping: (item: any) => Element,\r\n        placeholder?: Element\r\n    }\r\n}) => {\r\n    const {list, reactiveChildElement} = heldValue;\r\n    const reactiveChildrenElementsMapEntry = reactiveChildElementsMap.get(list);\r\n    if (reactiveChildrenElementsMapEntry) {\r\n        const {reactiveChildElementsArray} = reactiveChildrenElementsMapEntry;\r\n        reactiveChildElementsArray.splice(reactiveChildElementsArray.indexOf(reactiveChildElement), 1);\r\n    }\r\n});\r\n\r\nconst reactiveChildElementsObserver = new ModelChangeObserver((records: ModelChangeRecord[]) => {\r\n    let range: null | Range = null;\r\n    Array.from(records.values()).forEach((record_i) => {\r\n        const {target} = record_i;\r\n        const list = <ModelList>target;\r\n        const {length: listLength} = list;\r\n        const {reactiveChildElementsArray} = reactiveChildElementsMap.get(list)!;\r\n        reactiveChildElementsArray.forEach((reactiveChildElements_i) => {\r\n            const {parentRef, mapping, placeholder} = reactiveChildElements_i;\r\n            const parent = parentRef.deref();\r\n            if (parent) {\r\n                const {firstChild, children} = parent;\r\n                const {length: childrenCount} = children;\r\n                if (placeholder && listLength > 0 && firstChild == placeholder) {\r\n                    parent.removeChild(placeholder);\r\n                }\r\n                const {changeType, LIST_INSERT, LIST_REMOVE, LIST_SORT} = record_i;\r\n                switch (changeType) {\r\n                    case LIST_INSERT: {\r\n                        const {insertedIndex, insertedItems} = record_i;\r\n                        const insertedItemsArray = Array.from(insertedItems.values()).map(mapping);\r\n                        const {length: childrenCount} = children;\r\n                        if (insertedIndex < childrenCount) {\r\n                            children[insertedIndex].before(...insertedItemsArray);\r\n                        }\r\n                        else {\r\n                            parent.append(...insertedItemsArray);\r\n                        }\r\n                        break;\r\n                    }\r\n                    case LIST_REMOVE: {\r\n                        const {removedIndex, removedItems} = record_i;\r\n                        const {length: removedCount} = removedItems;\r\n                        range = range ?? document.createRange();\r\n                        const removeEndIndex = removedIndex + (removedCount - 1);\r\n                        if (removeEndIndex < childrenCount) {\r\n                            range.setStartBefore(children[removedIndex]);\r\n                            range.setEndAfter(children[removeEndIndex]);\r\n                            range.deleteContents();\r\n                        }\r\n                        break;\r\n                    }\r\n                    case LIST_SORT: {\r\n                        const {sortedIndices} = record_i;\r\n                        const childrenArray = Array.from(children);\r\n                        parent.append(\r\n                            ...sortedIndices.filter(\r\n                                index_i => index_i < childrenCount\r\n                            ).map(\r\n                                index_i => childrenArray[index_i]\r\n                            )\r\n                        );\r\n                        break;\r\n                    }\r\n                }\r\n                if (listLength == 0 && placeholder) {\r\n                    parent.append(placeholder);\r\n                }\r\n            }\r\n        });\r\n    });\r\n});\r\n\r\nfunction reactiveChildElements<Model extends ModelNode>(\r\n    list: ModelList<Model>,\r\n    mapping: (item: Model) => Element,\r\n    placeholder?: Element\r\n): ReactiveChildElements {\r\n    return (parent: ParentNode) => {\r\n        const parentRef = new WeakRef(parent);\r\n        const reactiveChildElementsMapEntry = reactiveChildElementsMap.get(list);\r\n        const reactiveChildElement = {parentRef, mapping, placeholder};\r\n        reactiveChildElementsFinalizationRegistry.register(parent, {list, reactiveChildElement});\r\n        if (!reactiveChildElementsMapEntry) {\r\n            const reactiveChildElementsArray = [reactiveChildElement];\r\n            reactiveChildElementsMap.set(list, {reactiveChildElementsArray});\r\n            reactiveChildElementsObserver.observe(list, {\r\n                childList: true\r\n            });\r\n        }\r\n        else {\r\n            const {reactiveChildElementsArray} = reactiveChildElementsMapEntry;\r\n            reactiveChildElementsArray.push(reactiveChildElement);\r\n        }\r\n        const children = list.length == 0 && placeholder ?\r\n            [placeholder] : Array.from(list.values()).map(mapping);\r\n        parent.replaceChildren(...children);\r\n    }\r\n}\r\n\r\nfunction revokeReactiveChildElements<Model extends ModelNode>(\r\n    list: ModelList<Model>,\r\n    parent: ParentNode,\r\n): void {\r\n    const reactiveChildElementsMapEntry = reactiveChildElementsMap.get(list);\r\n    if (reactiveChildElementsMapEntry) {\r\n        const {reactiveChildElementsArray} = reactiveChildElementsMapEntry;\r\n        const reactiveChildElementsIndex = reactiveChildElementsArray.findIndex(\r\n            reactiveChildElement => reactiveChildElement.parentRef.deref() === parent\r\n        );\r\n        if (reactiveChildElementsIndex > -1) {\r\n            reactiveChildElementsArray.splice(reactiveChildElementsIndex, 1);\r\n        }\r\n        if (reactiveChildElementsArray.length === 0) {\r\n            reactiveChildElementsMap.delete(list);\r\n        }\r\n    }\r\n}\r\n\r\ninterface AttributeMutationMixin {\r\n    readonly attributeName: string;\r\n    readonly attributeValue: string;\r\n    readonly attributeType: AttributeType;\r\n    attach(element: Element): void;\r\n    detach(element: Element): void;\r\n}\r\n\r\ntype AttributeType = \"string\" | \"boolean\" | \"list\";\r\n\r\nfunction areAttributesMatching(\r\n    referenceAttributeType: AttributeType,\r\n    referenceAttributeName: string, referenceAttributeValue: string,\r\n    attributeName: string, attributeValue: string | null): boolean {\r\n    if (referenceAttributeName == attributeName) {\r\n        switch (referenceAttributeType) {\r\n            case \"boolean\":\r\n                return referenceAttributeValue == \"\" && attributeValue == \"\";\r\n            case \"string\":\r\n                return referenceAttributeValue !== \"\" && (referenceAttributeValue == attributeValue);\r\n            case \"list\":\r\n                return (referenceAttributeValue !== \"\" && attributeValue !== null) && new RegExp(`${referenceAttributeValue}\\s*?`, \"g\").test(attributeValue );\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nclass AttributeMutationMixinBase implements AttributeMutationMixin {\r\n    readonly attributeName: string;\r\n    readonly attributeValue: string;\r\n    readonly attributeType: AttributeType;\r\n\r\n    constructor(attributeName: string, attributeType: AttributeType = \"boolean\", attributeValue: string = \"\") {\r\n        this.attributeName = attributeName;\r\n        this.attributeType = attributeType;\r\n        this.attributeValue = attributeValue;\r\n    }\r\n\r\n    attach(): void {\r\n        throw new TypeError(\"Not implemented method.\");\r\n    }\r\n\r\n    detach(): void {\r\n        throw new TypeError(\"Not implemented method.\");\r\n    }\r\n}","\r\nexport { snakeToCamel };\r\nexport { camelToSnake };\r\nexport { trainToCamel };\r\nexport { camelToTrain };\r\n\r\nfunction snakeToCamel(str: string) {\r\n  return str.split('_').map(str =>  str.charAt(0).toUpperCase() + str.substring(1).toLowerCase()).join(\"\");\r\n}\r\n\r\nfunction camelToSnake(str: string) {\r\n  return str.replace(/(?<!^)(?=[A-Z])/g, '_').toLowerCase();\r\n}\r\n\r\nfunction trainToCamel(str: string) {\r\n  return str.split('-').map(str =>  str.charAt(0).toUpperCase() + str.substring(1).toLowerCase()).join(\"\");\r\n}\r\n\r\nfunction camelToTrain(str: string) {\r\n  return str.replace(/(?<!^)(?=[A-Z])/g, '-').toLowerCase();\r\n}","export { ModelChangeRecord };\r\nexport { ModelEvent };\r\nexport { ModelNode };\r\nexport { ModelObject };\r\nexport { ModelProperty };\r\nexport { ModelList };\r\nexport { ModelChangeObserverOptions };\r\nexport { ModelChangeObserver };\r\n\r\ninterface ModelChangeRecordConstructor {\r\n    prototype: ModelChangeRecord;\r\n    new(\r\n        init: {\r\n            target: ModelNode | ModelList;\r\n            changeType: number;\r\n            propertyName?: string;\r\n            oldValue?: any;\r\n            newValue?: any;\r\n            removedIndex?: number,\r\n            removedItems?: ModelNode[],\r\n            insertedIndex?: number,\r\n            insertedItems?: ModelNode[],\r\n            sortedIndices?: number[]\r\n        }\r\n    ): ModelChangeRecord;\r\n    readonly PROPERTY_CHANGE: number;\r\n    readonly LIST_REMOVE: number;\r\n    readonly LIST_INSERT: number;\r\n    readonly LIST_SORT: number;\r\n}\r\n\r\ninterface ModelChangeRecord {\r\n    readonly target: ModelNode | ModelList\r\n    readonly propertyName: string | null;\r\n    readonly oldValue: any;\r\n    readonly newValue: any;\r\n    readonly changeType: number;\r\n    readonly removedIndex: number;\r\n    readonly removedItems: ModelNodesList;\r\n    readonly insertedIndex: number;\r\n    readonly insertedItems: ModelNodesList;\r\n    readonly sortedIndices: number[];\r\n    readonly PROPERTY_CHANGE: number;\r\n    readonly LIST_REMOVE: number;\r\n    readonly LIST_INSERT: number;\r\n    readonly LIST_SORT: number;\r\n}\r\n\r\nclass ModelChangeRecordBase implements ModelChangeRecord {\r\n    readonly target: ModelNode | ModelList;\r\n    readonly changeType: number;\r\n    readonly propertyName: string | null;\r\n    readonly oldValue: any;\r\n    readonly newValue: any;\r\n    readonly removedIndex: number;\r\n    readonly removedItems: ModelNodesList;\r\n    readonly insertedIndex: number;\r\n    readonly insertedItems: ModelNodesList;\r\n    readonly sortedIndices: number[];\r\n\r\n    constructor(\r\n        init: {\r\n            target: ModelNode | ModelList;\r\n            changeType: number;\r\n            propertyName?: string;\r\n            oldValue?: any;\r\n            newValue?: any;\r\n            removedIndex?: number,\r\n            removedItems?: ModelNode[],\r\n            insertedIndex?: number,\r\n            insertedItems?: ModelNode[],\r\n            sortedIndices?: number[]\r\n        }\r\n    ) {\r\n        this.target = init.target;\r\n        this.changeType = init.changeType;\r\n        this.propertyName = init.propertyName ?? null;\r\n        this.oldValue = init.oldValue ?? undefined;\r\n        this.newValue = init.newValue ?? undefined;\r\n        this.removedIndex = init.removedIndex ?? 0;\r\n        this.removedItems = new ModelNodesList(init.removedItems ?? []);\r\n        this.insertedIndex = init.insertedIndex ?? 0;\r\n        this.insertedItems = new ModelNodesList(init.insertedItems ?? []);\r\n        this.sortedIndices = init.sortedIndices ?? [];\r\n    }\r\n\r\n    static get PROPERTY_CHANGE(): number {\r\n        return 1;\r\n    }\r\n\r\n    static get LIST_REMOVE(): number {\r\n        return 2;\r\n    }\r\n\r\n    static get LIST_INSERT(): number {\r\n        return 3;\r\n    }\r\n\r\n    static get LIST_SORT(): number {\r\n        return 4;\r\n    }\r\n\r\n    get PROPERTY_CHANGE(): number {\r\n        return ModelChangeRecordBase.PROPERTY_CHANGE;\r\n    }\r\n\r\n    get LIST_REMOVE(): number {\r\n        return ModelChangeRecordBase.LIST_REMOVE;\r\n    }\r\n\r\n    get LIST_INSERT(): number {\r\n        return ModelChangeRecordBase.LIST_INSERT;\r\n    }\r\n\r\n    get LIST_SORT(): number {\r\n        return ModelChangeRecordBase.LIST_SORT;\r\n    }\r\n}\r\n\r\nvar ModelChangeRecord: ModelChangeRecordConstructor = ModelChangeRecordBase;\r\n\r\ninterface ModelNodesListConstructor {\r\n    prototype: ModelNodesList;\r\n    new(items: any[]): ModelNodesList;\r\n}\r\n\r\ninterface ModelNodesList {\r\n    get length(): number;\r\n    item(index: number): ModelNode | null;\r\n    values(): IterableIterator<ModelNode>;\r\n}\r\n\r\nclass ModelNodesListBase implements ModelNodesList {\r\n    #items: ModelNode[];\r\n\r\n    constructor(items: ModelNode[]) {\r\n        this.#items = items.slice();\r\n    }\r\n\r\n    get length(): number {\r\n        return this.#items.length;\r\n    }\r\n\r\n    item(index: number): ModelNode | null {\r\n        return this.#items[index] ?? null;\r\n    }\r\n\r\n    values(): IterableIterator<ModelNode> {\r\n        return this.#items.values();\r\n    }\r\n}\r\n\r\nvar ModelNodesList: ModelNodesListConstructor = ModelNodesListBase;\r\n\r\ninterface ModelEventConstructor {\r\n    prototype: ModelEvent;\r\n    new(type: string): ModelEvent;\r\n}\r\n\r\ninterface ModelEvent {\r\n    readonly type: string;\r\n    readonly currentTarget: ModelEventTarget | null;\r\n    readonly target: ModelEventTarget | null;\r\n}\r\n\r\nclass ModelEventBase implements ModelEvent {\r\n    readonly type: string;\r\n\r\n    #currentTarget: ModelEventTarget | null;\r\n    #target: ModelEventTarget | null;\r\n\r\n    constructor(type: string) {\r\n        this.type = type;\r\n        this.#currentTarget = null;\r\n        this.#target = null;\r\n    }\r\n\r\n    get currentTarget(): ModelEventTarget | null {\r\n        return this.#currentTarget;\r\n    }\r\n\r\n    get target(): ModelEventTarget | null {\r\n        return this.#target;\r\n    }\r\n\r\n    static ModelEventTargetAccessor? = new class ModelEventTargetAccessor {\r\n        setCurrentTarget(event: ModelEvent, currentTarget: ModelEventTarget): void {\r\n            if (event instanceof ModelEventBase) {\r\n                event.#currentTarget = currentTarget;\r\n            }\r\n        }\r\n\r\n        setTarget(event: ModelEvent, target: ModelEventTarget): void {\r\n            if (event instanceof ModelEventBase) {\r\n                event.#target = target;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface ModelEventTargetAccessor {\r\n    setCurrentTarget(event: ModelEvent, currentTarget: ModelEventTarget): void;\r\n    setTarget(event: ModelEvent, target: ModelEventTarget): void;\r\n}\r\n\r\nvar ModelEventTargetAccessor: ModelEventTargetAccessor = ModelEventBase.ModelEventTargetAccessor!;\r\ndelete ModelEventBase.ModelEventTargetAccessor;\r\n\r\nvar ModelEvent: ModelEventConstructor = ModelEventBase;\r\n\r\ninterface ModelEventTargetConstructor {\r\n    prototype: ModelEventTarget;\r\n    new(): ModelEventTarget;\r\n}\r\n\r\ninterface ModelEventTarget {\r\n    addEventListener(type: string, callback: (event: ModelEvent) => void): void;\r\n    removeEventListener(type: string, callback: (event: ModelEvent) => void): void;\r\n    dispatchEvent(event: ModelEvent): void;\r\n    receiveEvent(event: ModelEvent): void;\r\n}\r\n\r\nclass ModelEventTargetBase implements ModelEventTarget {\r\n    #callbacks: Map<string, ((event: ModelEvent) => void)[]>;\r\n\r\n    constructor() {\r\n        this.#callbacks = new Map();\r\n    }\r\n\r\n    receiveEvent(event: ModelEvent): void {\r\n        const {type} = event;\r\n        const callbacks = this.#callbacks.get(type);\r\n        ModelEventTargetAccessor.setCurrentTarget(event, this);\r\n        if (callbacks) {\r\n            callbacks.forEach((callback_i) => {\r\n                callback_i(event);\r\n            });\r\n        }\r\n    }\r\n\r\n    addEventListener(type: string, callback: (event: ModelEvent) => void): void {\r\n        const callbacks = this.#callbacks.get(type);\r\n        if (callbacks) {\r\n            callbacks.push(callback);\r\n        }\r\n        else {\r\n            this.#callbacks.set(type, [callback]);\r\n        }\r\n    }\r\n\r\n    removeEventListener(type: string, callback: (event: ModelEvent) => void): void {\r\n        const callbacks = this.#callbacks.get(type);\r\n        if (callbacks) {\r\n            const callbackIndex = callbacks.findIndex(\r\n                callback_i => callback_i == callback\r\n            );\r\n            if (callbackIndex > -1) {\r\n                callbacks.splice(callbackIndex, 1);\r\n            }\r\n            if (callbacks.length == 0) {\r\n                this.#callbacks.delete(type);\r\n            }\r\n        }\r\n    }\r\n\r\n    dispatchEvent(event: ModelEvent): void {\r\n        ModelEventTargetAccessor.setTarget(event, this);\r\n        this.receiveEvent(event);\r\n    }\r\n}\r\n\r\nvar ModelEventTarget: ModelEventTargetConstructor = ModelEventTargetBase;\r\n\r\ninterface ModelNodeConstructor {\r\n    prototype: ModelNode;\r\n    new(): ModelNode;\r\n}\r\n\r\ninterface ModelNode extends ModelEventTarget {\r\n    readonly parentNode: ModelNode | null;\r\n    setParent(parentNode: ModelNode | null): void;\r\n    getRecords(): ModelChangeRecord[];\r\n    beginChanges(): void;\r\n    endChanges(): void;\r\n}\r\n\r\ninterface ModelNodeRecordsAccessor {\r\n    triggerChange(node: ModelNode, property: string, oldValue: any, newValue: any): void;\r\n    handleRecord(node: ModelNode, record: ModelChangeRecord): void;\r\n}\r\n\r\nclass ModelNodeBase extends ModelEventTargetBase implements ModelNode {\r\n    #parentNode: ModelNode | null;\r\n    #records: ModelChangeRecord[];\r\n    #isRecording: boolean;\r\n\r\n    constructor() {\r\n        super();\r\n        this.#parentNode = null;\r\n        this.#records = [];\r\n        this.#isRecording = false;\r\n    }\r\n\r\n    get parentNode(): ModelNode | null {\r\n        return this.#parentNode;\r\n    }\r\n\r\n    setParent(parentNode: ModelNode | null): void {\r\n        if (parentNode !== null) {\r\n            let isCyclicReference = parentNode == this;\r\n            let {parentNode: ancestorNode} = parentNode;\r\n            while (!isCyclicReference && ancestorNode !== null) {\r\n                ({parentNode: ancestorNode} = ancestorNode);\r\n                isCyclicReference = ancestorNode == this;\r\n            }\r\n            if (!isCyclicReference) {\r\n                this.#parentNode = parentNode;\r\n            }\r\n            else {\r\n                throw new TypeError(\"Failed to set parent on ModelNode: circular reference detected in the hierarchy.\");\r\n            }\r\n        }\r\n        else {\r\n            this.#parentNode = null;\r\n        }\r\n    }\r\n    \r\n    beginChanges(): void {\r\n        this.#isRecording = true;\r\n    }\r\n\r\n    endChanges(): void {\r\n        this.dispatchEvent(new ModelEvent(\"modelchange\"));\r\n        this.#records.splice(0);\r\n        this.#isRecording = false;\r\n    }\r\n\r\n    getRecords(): ModelChangeRecord[] {\r\n        return this.#records.slice();\r\n    }\r\n\r\n    receiveEvent(event: ModelEvent): void {\r\n        super.receiveEvent(event);\r\n        const {parentNode} = this;\r\n        if (parentNode) {\r\n            parentNode.receiveEvent(event);\r\n        }\r\n    }\r\n\r\n    #triggerChange(property: string, oldValue: any, newValue: any): void {\r\n        const records = this.#records;\r\n        const record = new ModelChangeRecord({\r\n            target: this,\r\n            changeType: ModelChangeRecord.PROPERTY_CHANGE,\r\n            propertyName: property,\r\n            oldValue, newValue\r\n        });\r\n        records.push(record);\r\n        if (!this.#isRecording) {\r\n            this.dispatchEvent(new ModelEvent(\"modelchange\"));\r\n            records.splice(0);\r\n        }\r\n    }\r\n\r\n    #handleRecord(record: ModelChangeRecord): void {\r\n        this.#records.push(record);\r\n        if (!this.#isRecording) {\r\n            this.dispatchEvent(new ModelEvent(\"modelchange\"));\r\n            this.#records.splice(0);\r\n        }\r\n    }\r\n\r\n    static ModelNodeRecordsAccessor? = new class ModelNodeRecordsAccessor {\r\n        triggerChange(node: ModelNode, property: string, oldValue: any, newValue: any): void {\r\n            if (node instanceof ModelNodeBase) {\r\n                node.#triggerChange(property, oldValue, newValue);\r\n            }\r\n        }\r\n\r\n        handleRecord(node: ModelNode, record: ModelChangeRecord): void {\r\n            if (node instanceof ModelNodeBase) {\r\n                node.#handleRecord(record);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvar ModelNodeRecordsAccessor: ModelNodeRecordsAccessor = ModelNodeBase.ModelNodeRecordsAccessor!;\r\ndelete ModelNodeBase.ModelNodeRecordsAccessor;\r\n\r\nvar ModelNode: ModelNodeConstructor = ModelNodeBase;\r\n\r\ninterface ModelPropertyDecorator {\r\n    (): <Model extends ModelObject>(target: Model, property: string) => void;\r\n}\r\n\r\nconst ModelProperty: ModelPropertyDecorator = function() {\r\n    return (\r\n        target: ModelObject, property: string\r\n    ) => {\r\n        const {constructor} = target;\r\n        const {prototype} = constructor;\r\n        const setter = function(this: ModelObject, value: any) {\r\n            const oldValue = ModelObjectPropertiesAccessor.getProperty(this, property);\r\n            ModelObjectPropertiesAccessor.setProperty(this, property, value);\r\n            if (value !== oldValue) {\r\n                ModelNodeRecordsAccessor.triggerChange(this, property, oldValue, value);\r\n            }\r\n            return true;\r\n        };\r\n        const getter = function(this: ModelObject) {\r\n            return ModelObjectPropertiesAccessor.getProperty(this, property);\r\n        };\r\n        Object.defineProperty(prototype, property, {\r\n            set: setter,\r\n            get: getter,\r\n            enumerable: true\r\n        });\r\n    }\r\n}\r\n\r\ninterface ModelObjectConstructor {\r\n    prototype: ModelObject;\r\n    new(): ModelObject;\r\n}\r\n\r\ninterface ModelObject extends ModelNode {}\r\n\r\ninterface ModelObjectPropertiesAccessor {\r\n    setProperty(node: ModelNode, property: string, value: any): void;\r\n    getProperty(node: ModelNode, property: string,): any;\r\n}\r\n\r\nclass ModelObjectBase extends ModelNodeBase implements ModelObject {\r\n    #properties: Map<string, any>;\r\n\r\n    constructor() {\r\n        super();\r\n        this.#properties = new Map();\r\n    }\r\n\r\n    static ModelObjectPropertiesAccessor? = new class ModelPropertiesAccessor {\r\n        setProperty(node: ModelObject, property: string, value: any): void {\r\n            if (node instanceof ModelObjectBase) {\r\n                node.#properties.set(property, value);\r\n            }\r\n        }\r\n\r\n        getProperty(node: ModelObject, property: string): any {\r\n            if (node instanceof ModelObjectBase) {\r\n                return node.#properties.get(property);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvar ModelObjectPropertiesAccessor: ModelObjectPropertiesAccessor = ModelObjectBase.ModelObjectPropertiesAccessor!;\r\ndelete ModelObjectBase.ModelObjectPropertiesAccessor;\r\n\r\nvar ModelObject: ModelObjectConstructor = ModelObjectBase;\r\n\r\ninterface ModelListConstructor {\r\n    prototype: ModelList;\r\n    new<Model extends ModelNode>(): ModelList<Model>;\r\n    new<Model extends ModelNode>(items: Model[]): ModelList<Model>;\r\n}\r\n\r\ninterface ModelList<Model extends ModelNode = ModelNode> extends ModelNode {\r\n    readonly parentNode: ModelNode | null;\r\n    readonly length: number;\r\n    index(item: Model): number;\r\n    get(index: number): Model | null;\r\n    values(): IterableIterator<Model>;\r\n    sort(compareFunction: (item_a: any, item_b: any) => number): void;\r\n    insert(index: number, ...items: Model[]): void;\r\n    prepend(...items: Model[]): void;\r\n    append(...items: Model[]): void;\r\n    remove(item: Model): void;\r\n    clear(): void;\r\n}\r\n\r\nclass ModelListBase<Model extends ModelNode = ModelNode> extends ModelNodeBase implements ModelList<Model> {\r\n    #items: Model[];\r\n\r\n    constructor()\r\n    constructor(items: Model[])\r\n    constructor(items?: Model[]) {\r\n        super();\r\n        this.#items = items?.slice() ?? [];\r\n    }\r\n\r\n    setParent(parentNode: ModelNode | null): void {\r\n        super.setParent(parentNode);\r\n        this.#items.forEach((item_i) => {\r\n            item_i.setParent(parentNode);\r\n        });\r\n    }\r\n\r\n    get length(): number {\r\n        return this.#items.length;\r\n    }\r\n\r\n    get(index: number): Model | null {\r\n        return this.#items[index] ?? null;\r\n    }\r\n\r\n    index(item: Model): number {\r\n        return this.#items.indexOf(item);\r\n    }\r\n\r\n    values(): IterableIterator<Model> {\r\n        return this.#items.values();\r\n    }\r\n\r\n    sort(compareFunction: (item_a: any, item_b: any) => number): void {\r\n        const items = this.#items;\r\n        const indexedItems = items.map(\r\n            (item_i, i) => {\r\n                return {\r\n                    item: item_i,\r\n                    index: i\r\n                };\r\n            }\r\n        );\r\n        indexedItems.sort(\r\n            (indexedItem_a, indexedItem_b) => {\r\n                return compareFunction(\r\n                    indexedItem_a.item, indexedItem_b.item\r\n                )\r\n            }\r\n        );\r\n        this.#items = indexedItems.map(indexedItem_i => indexedItem_i.item);\r\n        const record = new ModelChangeRecord({\r\n            target: this,\r\n            changeType: ModelChangeRecord.LIST_SORT,\r\n            sortedIndices: indexedItems.map(indexedItem_i => indexedItem_i.index)\r\n        });\r\n        ModelNodeRecordsAccessor.handleRecord(this, record);\r\n    }\r\n\r\n    prepend(...items: Model[]): void {\r\n        const _items = this.#items;\r\n        const {parentNode} = this;\r\n        if (parentNode) {\r\n            items.forEach(item_i => {\r\n                item_i.setParent(parentNode);\r\n            });\r\n        }\r\n        _items.splice(0, 0, ...items);\r\n        const record = new ModelChangeRecord({\r\n            target: this,\r\n            changeType: ModelChangeRecord.LIST_INSERT,\r\n            insertedIndex: 0,\r\n            insertedItems: items\r\n        });\r\n        ModelNodeRecordsAccessor.handleRecord(this, record);\r\n    }\r\n\r\n    append(...items: Model[]): void {\r\n        const _items = this.#items;\r\n        const {length} = _items;\r\n        const {parentNode} = this;\r\n        if (parentNode) {\r\n            items.forEach(item_i => {\r\n                item_i.setParent(parentNode);\r\n            });\r\n        }\r\n        _items.push(...items);\r\n        const record = new ModelChangeRecord({\r\n            target: this,\r\n            changeType: ModelChangeRecord.LIST_INSERT,\r\n            insertedIndex: length,\r\n            insertedItems: items\r\n        });\r\n        ModelNodeRecordsAccessor.handleRecord(this, record);\r\n    }\r\n\r\n    insert(index: number, ...items: Model[]): void {\r\n        const _items = this.#items;\r\n        const {length} = _items;\r\n        const positiveIndex = Math.abs(index);\r\n        if (positiveIndex <= length) {\r\n            if (index >= 0) {\r\n                const {parentNode} = this;\r\n                items.forEach(item_i => {\r\n                    item_i.setParent(parentNode);\r\n                });\r\n                if (index < length) {\r\n                    _items.splice(index, 0, ...items);\r\n                }\r\n                else {\r\n                    _items.push(...items);\r\n                }\r\n            }\r\n            else if (index < 0) {\r\n                index = length - index;\r\n                const {parentNode} = this;\r\n                if (parentNode) {\r\n                    items.forEach(item_i => {\r\n                        item_i.setParent(parentNode);\r\n                    });\r\n                }\r\n                _items.splice(index, 0, ...items);\r\n            }\r\n            const record = new ModelChangeRecord({\r\n                target: this,\r\n                changeType: ModelChangeRecord.LIST_INSERT,\r\n                insertedIndex: index,\r\n                insertedItems: items.slice()\r\n            });\r\n            ModelNodeRecordsAccessor.handleRecord(this, record);\r\n        }\r\n    }\r\n\r\n    remove(item: Model): void {\r\n        const _items = this.#items;\r\n        const index = _items.indexOf(item);\r\n        if (index > -1) {\r\n            const item = _items.splice(index, 1)[0];\r\n            const {parentNode} = this;\r\n            if (parentNode) {\r\n                item.setParent(null);\r\n            }\r\n            const record = new ModelChangeRecord({\r\n                target: this,\r\n                changeType: ModelChangeRecord.LIST_REMOVE,\r\n                removedIndex: index,\r\n                removedItems: [item]\r\n            });\r\n            ModelNodeRecordsAccessor.handleRecord(this, record);\r\n        }\r\n    }\r\n\r\n    clear(): void {\r\n        const items = this.#items;\r\n        const {length} = items;\r\n        if (length > 0) {\r\n            const removedItems = items.splice(0);\r\n            const {parentNode} = this;\r\n            if (parentNode) {\r\n                removedItems.forEach((removedItem_i) => {\r\n                    removedItem_i.setParent(null);\r\n                });\r\n            }\r\n            const record = new ModelChangeRecord({\r\n                target: this,\r\n                changeType: ModelChangeRecord.LIST_REMOVE,\r\n                removedIndex: 0,\r\n                removedItems: removedItems\r\n            });\r\n            ModelNodeRecordsAccessor.handleRecord(this, record);\r\n        }\r\n    }\r\n};\r\n\r\nvar ModelList: ModelListConstructor = ModelListBase!;\r\n\r\ninterface ModelChangeObserverConstructor {\r\n    prototype: ModelChangeObserver;\r\n    new(callback: (records: ModelChangeRecord[]) => void): ModelChangeObserver;\r\n}\r\n\r\ninterface ModelChangeObserver {\r\n    observe(node: ModelNode, options: ModelChangeObserverOptions): void;\r\n    unobserve(node: ModelNode): void;\r\n    disconnect(): void;\r\n}\r\n\r\ntype ModelChangeObserverOptions = {\r\n    properties?: boolean;\r\n    propertiesFilter?: string[];\r\n    childList?: boolean;\r\n    subtree?: boolean;\r\n}\r\n\r\nclass ModelChangeObserverBase implements ModelChangeObserver {\r\n    #callback: (records: ModelChangeRecord[]) => void;\r\n    #records: ModelChangeRecord[];\r\n    #disconnected: boolean;\r\n\r\n    #references: WeakMap<ModelNode, {\r\n        listener: (event: ModelEvent) => void,\r\n        options: ModelChangeObserverOptions\r\n    }>;\r\n\r\n    constructor(callback: (records: ModelChangeRecord[]) => void) {\r\n        this.#callback = callback;\r\n        this.#records = [];\r\n        this.#disconnected = false;\r\n        this.#references = new WeakMap();\r\n    }\r\n\r\n    observe(node: ModelNode, options: ModelChangeObserverOptions): void {\r\n        this.#disconnected = false;\r\n        const references = this.#references;\r\n        let reference = references.get(node);\r\n        if (!reference) {\r\n            const listener = this.#handleModelEvent.bind(this);\r\n            node.addEventListener(\"modelchange\", listener);\r\n            reference = {listener, options};\r\n            references.set(node, reference);\r\n        }\r\n        else {\r\n            references.set(node, reference);\r\n        }\r\n    }\r\n\r\n    unobserve(node: ModelNode): void {\r\n        const references = this.#references;\r\n        let reference = references.get(node);\r\n        if (reference) {\r\n            const {listener} = reference;\r\n            node.removeEventListener(\"modelchange\", listener);\r\n        }\r\n    }\r\n\r\n    disconnect(): void {\r\n        this.#records.splice(0);\r\n        this.#disconnected = true;\r\n    }\r\n\r\n    #trigger(): void {\r\n        const records = this.#records.splice(0);\r\n        if (records.length > 0) {\r\n            this.#callback(records);\r\n        }\r\n    }\r\n\r\n    #handleModelEvent(event: ModelEvent): void {\r\n        if (!this.#disconnected) {\r\n            const {target, currentTarget} = event;\r\n            const reference = this.#references.get(<ModelNode>currentTarget);\r\n            if (reference) {\r\n                const {options} = reference;\r\n                const {properties, propertiesFilter, childList, subtree} = options;\r\n                if (subtree) {\r\n                    if (properties && target instanceof ModelNode) {\r\n                        if (propertiesFilter) {\r\n                            this.#records.push(\r\n                                ...target.getRecords()\r\n                                    .filter(record_i => {\r\n                                        const {propertyName} = record_i;\r\n                                        return propertiesFilter.includes(\r\n                                            propertyName!\r\n                                        )\r\n                                    })\r\n                            );\r\n                        }\r\n                        else {\r\n                            this.#records.push(\r\n                                ...target.getRecords()\r\n                            );\r\n                        }\r\n                        this.#trigger();\r\n                    }\r\n                    else if (childList && target instanceof ModelList) {\r\n                        this.#records.push(\r\n                            ...target.getRecords()\r\n                        );\r\n                        this.#trigger();\r\n                    }\r\n                }\r\n                else if (target == currentTarget) {\r\n                    if (properties && target instanceof ModelNode) {\r\n                        if (propertiesFilter) {\r\n                            this.#records.push(\r\n                                ...target.getRecords()\r\n                                    .filter(record_i => {\r\n                                        const {propertyName} = record_i;\r\n                                        return propertiesFilter.includes(\r\n                                            propertyName!\r\n                                        )\r\n                                    })\r\n                            );\r\n                        }\r\n                        else {\r\n                            this.#records.push(\r\n                                ...target.getRecords()\r\n                            );\r\n                        }\r\n                        this.#trigger();\r\n                    }\r\n                    else if (childList && target instanceof ModelList) {\r\n                        this.#records.push(\r\n                            ...target.getRecords()\r\n                        );\r\n                        this.#trigger();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvar ModelChangeObserver: ModelChangeObserverConstructor = ModelChangeObserverBase;","import { ReactiveChildElements } from \"../../elements/Element\";\r\nimport { camelToTrain } from \"../../elements/Snippets\";\r\n\r\nexport { WidgetFactoryConstructor };\r\n\r\nexport { widget };\r\nexport { Widget };\r\nexport { WidgetFactory };\r\nexport { widgets };\r\n\r\ndeclare global {\r\n    interface WidgetNameMap {}\r\n}\r\n\r\ninterface WidgetFactoryConstructor {\r\n    prototype: WidgetFactory;\r\n    new(): WidgetFactory;\r\n}\r\n\r\ninterface WidgetFactory {\r\n    create(properties?: object): HTMLElement;\r\n    slot(root: HTMLElement, name: string | null): HTMLElement | null;\r\n}\r\n\r\nvar slotsMap: WeakMap<HTMLElement, {\r\n    widget: WidgetFactory,\r\n    element: WeakRef<HTMLElement>;\r\n    slot: string | null;\r\n}[]> = new WeakMap();\r\nvar slotsObserver = new MutationObserver(\r\n    (mutationsList: MutationRecord[]) => {\r\n        mutationsList.forEach((mutation: MutationRecord) => {\r\n            const {target, type} = mutation;\r\n            if (target instanceof HTMLElement) {\r\n                switch (type) {\r\n                    case \"childList\": {\r\n                        const slotReferences = slotsMap.get(target);\r\n                        if (slotReferences) {\r\n                            slotReferences.forEach(slotRef_i => {\r\n                                const {widget, element, slot} = slotRef_i;\r\n                                const slottedCallback = (widget as any)[\"slottedCallback\"];\r\n                                if (typeof slottedCallback == \"function\") {\r\n                                    slottedCallback(element.deref(), target, slot);\r\n                                }\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n);\r\n\r\nvar widgetsMap: WeakMap<HTMLElement, WidgetFactory> = new WeakMap();\r\nvar attributesObserver = new MutationObserver(\r\n    (mutationsList: MutationRecord[]) => {\r\n        mutationsList.forEach((mutation: MutationRecord) => {\r\n            const {target, type} = mutation;\r\n            if (target instanceof HTMLElement) {\r\n                switch (type) {\r\n                    case \"attributes\": {\r\n                        const {attributeName, oldValue} = mutation;\r\n                        const widget = widgetsMap.get(target);\r\n                        if (widget) {\r\n                            const attributeChangedCallback = (widget as any)[\"attributeChangedCallback\"];\r\n                            if (typeof attributeChangedCallback == \"function\") {\r\n                                attributeChangedCallback(target, attributeName, oldValue, target.getAttribute(attributeName!));\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n);\r\n\r\nclass WidgetFactoryBase implements WidgetFactory {\r\n\r\n    constructor() {\r\n        const widget = <WidgetFactory>this;\r\n        this.create = new Proxy(\r\n            this.create, {\r\n                apply: (target, thisArg, argumentsList: Parameters<WidgetFactory[\"create\"]>) => {\r\n                    const element = <HTMLElement>Reflect.apply(target, thisArg, argumentsList);\r\n                    const observedSlots = <(string | null)[]>(widget as any)[\"observedSlots\"];\r\n                    if (Array.isArray(observedSlots)) {\r\n                        const slots = observedSlots\r\n                            .map(slotName_i => {\r\n                                return {\r\n                                    slotName: slotName_i,\r\n                                    slotElement: widget.slot(element, slotName_i)\r\n                                };\r\n                            });\r\n                        slots.forEach(slot_i => {\r\n                            const {slotElement, slotName} = slot_i;\r\n                            if (slotElement) {\r\n                                slotsObserver.observe(slotElement, {\r\n                                    childList: true\r\n                                });\r\n                                const slotReferences = slotsMap.get(slotElement);\r\n                                const slotReference = {widget, element: new WeakRef(element), slot: slotName};\r\n                                if (Array.isArray(slotReferences)) {\r\n                                    slotReferences.push(slotReference);\r\n                                }\r\n                                else {\r\n                                    slotsMap.set(slotElement, new Array(slotReference));\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                    const observedAttributes = (widget as any)[\"observedAttributes\"];\r\n                    if (Array.isArray(observedAttributes)) {\r\n                        widgetsMap.set(element, widget);\r\n                        attributesObserver.observe(element, {\r\n                            attributes: true,\r\n                            attributeFilter: observedAttributes,\r\n                            attributeOldValue: true\r\n                        });\r\n                    }\r\n                    return element;\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    create(): HTMLElement {\r\n        throw new Error(`create method is not implemented`);\r\n    }\r\n\r\n    slot(): HTMLElement | null {\r\n        return null;\r\n    }\r\n\r\n    get observedSlots(): string[] {\r\n        return [\"\"];\r\n    }\r\n}\r\n\r\nvar WidgetFactory: WidgetFactoryConstructor = WidgetFactoryBase;\r\nvar widgets: Map<string, WidgetFactory> = new Map();\r\n\r\ninterface WidgetInit<K extends keyof WidgetNameMap> {\r\n    properties?: Parameters<WidgetNameMap[K][\"create\"]>[0],\r\n    attributes?: {\r\n        [name: string]: number | string | boolean\r\n    },\r\n    dataset?: {\r\n        [property: string]: string | number | boolean\r\n    },\r\n    slotted?: {\r\n        [slot: string]: Node | string | (Node | string)[] | NodeList | ReactiveChildElements\r\n    } | (Node | string | (Node | string)[] | NodeList | ReactiveChildElements),\r\n    listeners?: {\r\n        [EventName in keyof HTMLElementEventMap]?: EventListenerOrEventListenerObject | [EventListenerOrEventListenerObject, boolean | AddEventListenerOptions | undefined]\r\n    }\r\n}\r\n\r\nfunction widget<K extends keyof WidgetNameMap>(\r\n    name: K, init?: WidgetInit<K>): ReturnType<WidgetNameMap[K][\"create\"]>;\r\nfunction widget<K extends keyof WidgetNameMap>(\r\n    name: K, init?: WidgetInit<K>): HTMLElement {\r\n    const widget = widgets.get(name);\r\n    if (widget) {\r\n        if (init !== undefined) {\r\n            const {properties, attributes, dataset, slotted, listeners} = init;\r\n            const element = widget.create(properties);\r\n            if (attributes) {\r\n                Object.entries(attributes).forEach(([attributeName, attributeValue]) => {\r\n                    if (attributeValue !== undefined) {\r\n                        if (typeof attributeValue === \"boolean\") {\r\n                            element.toggleAttribute(camelToTrain(attributeName), attributeValue);\r\n                        }\r\n                        else {\r\n                            element.setAttribute(camelToTrain(attributeName), String(attributeValue));\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            if (dataset) {\r\n                const {dataset: elementDataset} = element;\r\n                Object.keys(dataset).forEach((datasetEntry_i) => {\r\n                    elementDataset[datasetEntry_i] = String(dataset[datasetEntry_i]);\r\n                });\r\n            }\r\n            if (slotted) {\r\n                if (typeof slotted === \"function\" || Array.isArray(slotted) || slotted instanceof NodeList || typeof slotted === \"string\" || slotted instanceof Node) {\r\n                    const slot = widget.slot(element, null);\r\n                    if (slot) {\r\n                        if (typeof slotted === \"function\") {\r\n                            slotted(slot);\r\n                        }\r\n                        else if (typeof slotted === \"object\" && \"length\" in slotted) {\r\n                            slot.append(...Array.from(slotted));\r\n                        }\r\n                        else {\r\n                            slot.append(slotted);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    Object.entries(slotted).forEach(([slot_i, slotted]) => {\r\n                        const slot = widget.slot(element, slot_i);\r\n                        if (slot) {\r\n                            if (typeof slotted === \"function\") {\r\n                                slotted(slot);\r\n                            }\r\n                            else if (typeof slotted === \"object\" && \"length\" in slotted) {\r\n                                slot.append(...Array.from(slotted));\r\n                            }\r\n                            else {\r\n                                slot.append(slotted);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            if (listeners) {\r\n                Object.entries(listeners).forEach(([name_i, listener_i]) => {\r\n                    if (Array.isArray(listener_i)) {\r\n                        element.addEventListener(name_i, listener_i[0], listener_i[1]);\r\n                    }\r\n                    else {\r\n                        element.addEventListener(name_i, listener_i);\r\n                    }\r\n                });\r\n            }\r\n            return element;\r\n        }\r\n        else {\r\n            return widget.create();\r\n        }\r\n    }\r\n    throw new Error(`Unknown widget ${name}. The corresponding module might not be imported.`);\r\n}\r\n\r\ninterface WidgetDecorator {\r\n    (init: {\r\n        name: string;\r\n    }): <W extends WidgetFactoryConstructor>(widget: W) => W;\r\n}\r\n\r\nconst Widget: WidgetDecorator = function(init: {\r\n    name: string;\r\n}) {\r\n    return <W extends WidgetFactoryConstructor>(\r\n        widget: W\r\n    ) => {\r\n        const {name} = init;\r\n        widgets.set(\r\n            name,\r\n            new widget()\r\n        );\r\n        return widget;\r\n    }\r\n}","import { element } from \"../../../elements/Element\";\r\nimport { Widget, WidgetFactory } from \"../Widget\";\r\n\r\nexport { gridCellWidget };\r\n\r\ninterface GridCellWidgetFactory extends WidgetFactory {\r\n    create(init: {\r\n        id?: string;\r\n        classList?: string[];\r\n        tabIndex?: number;\r\n        disabled?: boolean;\r\n        headers?: string;\r\n    }): HTMLElement;\r\n    getHeaders(item: HTMLElement): string;\r\n    setHeaders(item: HTMLElement, value: string): void;\r\n    setPosInSet(item: HTMLElement, value: number): void;\r\n    getPosInSet(item: HTMLElement): number;\r\n    setActive(item: HTMLElement, value: boolean): void;\r\n    getActive(item: HTMLElement): boolean;\r\n    setDropTarget(item: HTMLElement, value: boolean): void;\r\n    getDropTarget(item: HTMLElement): boolean;\r\n    setDisabled(item: HTMLElement, value: boolean): void;\r\n    getDisabled(item: HTMLElement): boolean;\r\n    setSelected(item: HTMLElement, value: boolean): void;\r\n    getSelected(item: HTMLElement): boolean;\r\n}\r\n\r\ndeclare global {\r\n    interface WidgetNameMap {\r\n        \"gridcell\": GridCellWidgetFactory,\r\n    }\r\n}\r\n\r\nvar gridCellWidget = new (\r\nWidget({\r\n    name: \"gridcell\"\r\n})(class GridCellWidgetFactoryBase extends WidgetFactory implements GridCellWidgetFactory {\r\n    #template: HTMLElement;\r\n\r\n    constructor() {\r\n        super();\r\n        this.#template = element(\"td\", {\r\n            attributes: {\r\n                class: \"gridcell\",\r\n                role: \"gridcell\",\r\n                tabindex: -1\r\n            }\r\n        });\r\n    }\r\n\r\n    create(init?: {\r\n        id?: string;\r\n        classList?: string[];\r\n        tabIndex?: number;\r\n        disabled?: boolean;\r\n        headers?: string;\r\n    }): HTMLElement {\r\n        const cell = <HTMLElement>this.#template.cloneNode(true);\r\n        if (init !== undefined) {\r\n            const {id, classList, tabIndex, disabled, headers} = init;\r\n            if (id !== undefined) {\r\n                cell.id = id;\r\n            }\r\n            if (classList !== undefined) {\r\n                cell.classList.add(...classList);\r\n            }\r\n            if (tabIndex !== undefined) {\r\n                cell.tabIndex = tabIndex;\r\n            }\r\n            if (disabled !== undefined) {\r\n                this.setDisabled(cell, disabled);\r\n            }\r\n            if (headers !== undefined) {\r\n                this.setHeaders(cell, headers);\r\n            }\r\n            this.setSelected(cell, false);\r\n        }\r\n        return cell;\r\n    }\r\n\r\n    slot(cell: HTMLElement): HTMLElement | null {\r\n        return cell;\r\n    }\r\n\r\n    getHeaders(item: HTMLElement): string {\r\n        return item.getAttribute(\"headers\") ?? \"\";\r\n    }\r\n\r\n    setHeaders(item: HTMLElement, value: string): void {\r\n        item.setAttribute(\"headers\", value);\r\n    }\r\n\r\n    getLabel(item: HTMLElement): string {\r\n        return this.#label(item).textContent ?? \"\";\r\n    }\r\n\r\n    setLabel(item: HTMLElement, value: string): void {\r\n        this.#label(item).textContent = value;\r\n    }\r\n\r\n    setPosInSet(item: HTMLElement, value: number): void {\r\n        item.setAttribute(\"aria-posinset\", String(value));\r\n    }\r\n\r\n    getPosInSet(item: HTMLElement): number {\r\n        const posInSet = item.getAttribute(\"aria-posinset\");\r\n        return posInSet ? parseInt(posInSet) : -1;\r\n    }\r\n\r\n    setActive(item: HTMLElement, value: boolean): void {\r\n        const {classList} = item;\r\n        if (value) {\r\n            classList.add(\"active\");\r\n        }\r\n        else {\r\n            classList.remove(\"active\");\r\n        }\r\n    }\r\n\r\n    getActive(item: HTMLElement): boolean {\r\n        const {classList} = item;\r\n        return classList.contains(\"active\");\r\n    }\r\n\r\n    setDropTarget(item: HTMLElement, value: boolean): void {\r\n        const {classList} = item;\r\n        if (value) {\r\n            classList.add(\"droptarget\");\r\n        }\r\n        else {\r\n            classList.remove(\"droptarget\");\r\n        }\r\n    }\r\n\r\n    getDropTarget(item: HTMLElement): boolean {\r\n        const {classList} = item;\r\n        return classList.contains(\"droptarget\");\r\n    }\r\n\r\n    setDisabled(item: HTMLElement, value: boolean): void {\r\n        item.toggleAttribute(\"aria-disabled\", value);\r\n    }\r\n\r\n    getDisabled(item: HTMLElement): boolean {\r\n        return item.hasAttribute(\"aria-disabled\");\r\n    }\r\n\r\n    setSelected(item: HTMLElement, value: boolean): void {\r\n        item.setAttribute(\"aria-selected\", String(value));\r\n        item.dispatchEvent(new Event(\"select\", {bubbles: true}));\r\n    }\r\n\r\n    getSelected(item: HTMLElement): boolean {\r\n        return JSON.parse(item.getAttribute(\"aria-selected\") ?? String(false));\r\n    }\r\n\r\n    #label(item: HTMLElement): HTMLElement {\r\n        return item.querySelector<HTMLElement>(\":scope > .content > .label\")!;\r\n    }\r\n}));","import { element } from \"../../../elements/Element\";\r\nimport { Widget, WidgetFactory } from \"../Widget\";\r\nimport { gridCellWidget } from \"./GridCellWidget\";\r\n\r\nexport { gridRowWidget };\r\n\r\ninterface GridRowWidgetFactory extends WidgetFactory {\r\n    create(init?: {\r\n        disabled?: boolean\r\n    }): HTMLElement;\r\n    cells(row: HTMLElement): HTMLElement[];\r\n    setPosInSet(row: HTMLElement, value: number): void;\r\n    getPosInSet(row: HTMLElement): number;\r\n    setActive(row: HTMLElement, value: boolean): void;\r\n    getActive(row: HTMLElement): boolean;\r\n    setDropTarget(row: HTMLElement, value: boolean): void;\r\n    getDropTarget(row: HTMLElement): boolean;\r\n    setSelected(row: HTMLElement, value: boolean): void;\r\n    getSelected(row: HTMLElement): boolean;\r\n    setDisabled(row: HTMLElement, value: boolean): void;\r\n    getDisabled(row: HTMLElement): boolean;\r\n}\r\n\r\ndeclare global {\r\n    interface WidgetNameMap {\r\n        \"gridrow\": GridRowWidgetFactory,\r\n    }\r\n}\r\n\r\nvar gridRowWidget = new (\r\nWidget({\r\n    name: \"gridrow\"\r\n})(class GridRowWidgetFactoryBase extends WidgetFactory implements GridRowWidgetFactory {\r\n    #template: HTMLElement;\r\n\r\n    constructor() {\r\n        super();\r\n        this.#template = element(\"tr\", {\r\n            attributes: {\r\n                class: \"gridrow\",\r\n                role: \"row\",\r\n                tabindex: -1\r\n            }\r\n        });\r\n    }\r\n\r\n    create(init?: {\r\n        disabled?: boolean;\r\n    }): HTMLElement {\r\n        const row = <HTMLElement>this.#template.cloneNode(true);\r\n        if (init !== undefined) {\r\n            const {disabled} = init;\r\n            if (disabled !== undefined) {\r\n                this.setDisabled(row, disabled);\r\n            }\r\n            this.setSelected(row, false);\r\n        }\r\n        return row;\r\n    }\r\n\r\n    slot(row: HTMLElement): HTMLElement | null {\r\n        return row;\r\n    }\r\n\r\n    cells(row: HTMLElement): HTMLElement[] {\r\n        return Array.from(row.querySelectorAll<HTMLElement>(\r\n            \":scope > .gridcell\"\r\n        ));\r\n    }\r\n    \r\n    setPosInSet(row: HTMLElement, value: number): void {\r\n        row.setAttribute(\"aria-posinset\", String(value));\r\n    }\r\n\r\n    getPosInSet(row: HTMLElement): number {\r\n        const posInSet = row.getAttribute(\"aria-posinset\");\r\n        return posInSet ? parseInt(posInSet) : -1;\r\n    }\r\n\r\n    setActive(row: HTMLElement, value: boolean): void {\r\n        const {classList} = row;\r\n        if (value) {\r\n            classList.add(\"active\");\r\n        }\r\n        else {\r\n            classList.remove(\"active\");\r\n        }\r\n    }\r\n\r\n    getActive(row: HTMLElement): boolean {\r\n        const {classList} = row;\r\n        return classList.contains(\"active\");\r\n    }\r\n\r\n    setDropTarget(row: HTMLElement, value: boolean): void {\r\n        const {classList} = row;\r\n        if (value) {\r\n            classList.add(\"droptarget\");\r\n        }\r\n        else {\r\n            classList.remove(\"droptarget\");\r\n        }\r\n    }\r\n\r\n    getDropTarget(row: HTMLElement): boolean {\r\n        const {classList} = row;\r\n        return classList.contains(\"droptarget\");\r\n    }\r\n\r\n    setDisabled(row: HTMLElement, value: boolean): void {\r\n        row.toggleAttribute(\"aria-disabled\", value);\r\n    }\r\n\r\n    getDisabled(row: HTMLElement): boolean {\r\n        return row.hasAttribute(\"aria-disabled\");\r\n    }\r\n\r\n    setSelected(row: HTMLElement, value: boolean): void {\r\n        row.setAttribute(\"aria-selected\", String(value));\r\n        row.dispatchEvent(new Event(\"select\", {bubbles: true}));\r\n    }\r\n\r\n    getSelected(row: HTMLElement): boolean {\r\n        return JSON.parse(row.getAttribute(\"aria-selected\") ?? String(false));\r\n    }\r\n\r\n    slottedCallback(item: HTMLElement, slot: HTMLElement) {\r\n        const {childNodes} = slot;\r\n        Array.from(childNodes).forEach((item_i, i) => {\r\n            if (item_i instanceof HTMLElement) {\r\n                gridCellWidget.setPosInSet(item_i, i);\r\n            }\r\n        });\r\n    }\r\n}));","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import { element } from \"../../../elements/Element\";\r\nimport { Widget, WidgetFactory } from \"../Widget\";\r\nimport { gridCellWidget } from \"./GridCellWidget\";\r\nimport { gridRowWidget } from \"./GridRowWidget\";\r\n\r\nexport { gridWidget };\r\n\r\ntype GridSelectBy = \"cell\" | \"row\";\r\n\r\ninterface GridRowWidgetFactory extends WidgetFactory {\r\n    create(properties?: {\r\n        id?: string;\r\n        classList?: string[];\r\n        tabIndex?: number;\r\n        multisectable?: boolean;\r\n        selectby?: GridSelectBy\r\n    }): HTMLElement;\r\n    setSelectBy(item: HTMLElement, value: GridSelectBy): void;\r\n    getSelectBy(item: HTMLElement): GridSelectBy;\r\n    headers(grid: HTMLElement): HTMLElement[];\r\n    cells(grid: HTMLElement): HTMLElement[];\r\n    rows(grid: HTMLElement): HTMLElement[];\r\n    beginSelection(grid: HTMLElement): void;\r\n    endSelection(grid: HTMLElement): void;\r\n    selectedCells(grid: HTMLElement): HTMLElement[];\r\n    selectedRows(grid: HTMLElement): HTMLElement[];\r\n    clearSelection(grid: HTMLElement): void;\r\n}\r\n\r\ndeclare global {\r\n    interface WidgetNameMap {\r\n        \"grid\": GridRowWidgetFactory,\r\n    }\r\n}\r\n\r\nvar gridWidget = new (\r\nWidget({\r\n    name: \"grid\"\r\n})(class GridWidgetFactoryBase extends WidgetFactory implements GridRowWidgetFactory {\r\n\r\n    #getActiveRow(grid: HTMLElement): HTMLElement | null {\r\n        return grid.querySelector<HTMLElement>(\".gridrow.active\");\r\n    }\r\n\r\n    #getActiveCell(grid: HTMLElement): HTMLElement | null {\r\n        return grid.querySelector<HTMLElement>(\".gridcell.active\");\r\n    }\r\n\r\n    headers(grid: HTMLElement): HTMLElement[] {\r\n        return Array.from(grid.querySelectorAll<HTMLElement>(\r\n            \":scope > .gridhead > .gridheader\"\r\n        ));\r\n    }\r\n\r\n    rows(grid: HTMLElement): HTMLElement[] {\r\n        return Array.from(grid.querySelectorAll<HTMLElement>(\r\n            \":scope > .gridbody > .gridrow\"\r\n        ));\r\n    }\r\n\r\n    cells(grid: HTMLElement): HTMLElement[] {\r\n        return Array.from(grid.querySelectorAll<HTMLElement>(\r\n            \":scope > .gridbody > .gridrow > .gridcell\"\r\n        ));\r\n    }\r\n\r\n    #template: HTMLElement;\r\n    #rowsWalker: TreeWalker;\r\n    #cellsWalker: TreeWalker;\r\n    #onSelection: WeakMap<HTMLElement, boolean>;\r\n    #hasSelectionChanged: WeakMap<HTMLElement, boolean>;\r\n\r\n    constructor() {\r\n        super();\r\n        this.#template = element(\"table\", {\r\n            attributes: {\r\n                class: \"grid\",\r\n                role: \"grid\",\r\n                tabindex: 0\r\n            }\r\n        });\r\n        this.#onSelection = new WeakMap();\r\n        this.#hasSelectionChanged = new WeakMap();\r\n        this.#cellsWalker = document.createTreeWalker(\r\n            document, NodeFilter.SHOW_ELEMENT, this.#cellsWalkerNodeFilter.bind(this)\r\n        );\r\n        this.#rowsWalker = document.createTreeWalker(\r\n            document, NodeFilter.SHOW_ELEMENT, this.#rowsWalkerNodeFilter.bind(this)\r\n        );\r\n    }\r\n\r\n    create(properties?: {\r\n        id?: string;\r\n        classList?: string[];\r\n        tabIndex?: number;\r\n        multisectable?: boolean;\r\n        selectby?: GridSelectBy;\r\n    }) {\r\n        const grid = <HTMLElement>this.#template.cloneNode(true);\r\n        //grid.addEventListener(\"contextmenu\", this.#handleContextMenuEvent.bind(this));\r\n        grid.addEventListener(\"mousedown\", this.#handleMouseDownEvent.bind(this));\r\n        grid.addEventListener(\"focus\", this.#handleFocusEvent.bind(this));\r\n        grid.addEventListener(\"focusin\", this.#handleFocusInEvent.bind(this));\r\n        grid.addEventListener(\"focusout\", this.#handleFocusOutEvent.bind(this));\r\n        grid.addEventListener(\"keydown\", this.#handleKeyDownEvent.bind(this));\r\n        grid.addEventListener(\"select\", this.#handleSelectEvent.bind(this));\r\n        if (properties !== undefined) {\r\n            const {id, classList, tabIndex, selectby, multisectable} = properties;\r\n            if (id !== undefined) {\r\n                grid.id = id;\r\n            }\r\n            if (classList !== undefined) {\r\n                grid.classList.add(...classList);\r\n            }\r\n            if (tabIndex !== undefined) {\r\n                grid.tabIndex = tabIndex;\r\n            }\r\n            if (selectby !== undefined) {\r\n                this.setSelectBy(grid, selectby);\r\n            }\r\n            if (multisectable !== undefined) {\r\n                this.setMultiSelectable(grid, multisectable);\r\n            }\r\n        }\r\n        return grid;\r\n    }\r\n\r\n    slot(grid: HTMLElement): HTMLElement | null {\r\n        return grid;\r\n    }\r\n\r\n    setMultiSelectable(grid: HTMLElement, value: boolean): void {\r\n        grid.setAttribute(\"aria-multiselectable\", String(value));\r\n    }\r\n\r\n    getMultiSelectable(grid: HTMLElement): boolean {\r\n        return JSON.parse(grid.getAttribute(\"aria-multiselectable\") ?? String(false));\r\n    }\r\n\r\n    setSelectBy(grid: HTMLElement, value: GridSelectBy): void {\r\n        grid.setAttribute(\"data-selectby\", value);\r\n    }\r\n\r\n    getSelectBy(grid: HTMLElement): GridSelectBy {\r\n        return <GridSelectBy>grid.getAttribute(\"data-selectby\") ?? \"cell\";\r\n    }\r\n\r\n    beginSelection(grid: HTMLElement): void {\r\n        this.#onSelection.set(grid, true);\r\n    }\r\n\r\n    endSelection(grid: HTMLElement): void {\r\n        this.#onSelection.set(grid, false);\r\n        if (this.#hasSelectionChanged.get(grid)) {\r\n            grid.dispatchEvent(new Event(\"selectionchange\", {bubbles: true}));\r\n            this.#hasSelectionChanged.set(grid, false);\r\n        }\r\n    }\r\n\r\n    clearSelection(grid: HTMLElement): void {\r\n        this.#clearCellsSelection(grid);\r\n        this.#clearRowsSelection(grid);\r\n    }\r\n\r\n    selectedCells(grid: HTMLElement): HTMLElement[] {\r\n        return Array.from(grid.querySelectorAll(\":scope > .gridbody > .gridrow > .gridcell[aria-selected=true]\"));\r\n    }\r\n\r\n    selectedRows(grid: HTMLElement): HTMLElement[] {\r\n        return Array.from(grid.querySelectorAll(\":scope > .gridbody > .gridrow[aria-selected=true]\"));\r\n    }\r\n\r\n    #cellsWalkerNodeFilter(node: Node): number {\r\n        if (node instanceof HTMLElement) {\r\n            const {classList} = node;\r\n            if (classList.contains(\"gridcell\") && !gridCellWidget.getDisabled(node) && !node.hidden) {\r\n                return NodeFilter.FILTER_ACCEPT;\r\n            }\r\n            else if (classList.contains(\"gridrow\") || classList.contains(\"gridbody\")) {\r\n                return NodeFilter.FILTER_SKIP;\r\n            }\r\n        }\r\n        return NodeFilter.FILTER_REJECT;\r\n    }\r\n\r\n    #rowsWalkerNodeFilter(node: Node): number {\r\n        if (node instanceof HTMLElement) {\r\n            const {classList} = node;\r\n            if (classList.contains(\"gridrow\") && !gridRowWidget.getDisabled(node) && !node.hidden) {\r\n                return NodeFilter.FILTER_ACCEPT;\r\n            }\r\n            else if (classList.contains(\"gridbody\")) {\r\n                return NodeFilter.FILTER_SKIP;\r\n            }\r\n        }\r\n        return NodeFilter.FILTER_REJECT;\r\n    }\r\n\r\n    #getCellsRange(from: HTMLElement, to: HTMLElement): HTMLElement[] {\r\n        if (from == to) {\r\n            return [from];\r\n        }\r\n        const position = from.compareDocumentPosition(to);\r\n        if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\r\n            const range = [from];\r\n            let nextCell = this.#nextCell(from);\r\n            while (nextCell && nextCell !== to) {\r\n                range.push(nextCell);\r\n                nextCell = this.#nextCell(nextCell);\r\n            }\r\n            range.push(to);\r\n            return range;\r\n        }\r\n        else if (position & Node.DOCUMENT_POSITION_PRECEDING) {\r\n            const range = [from];\r\n            let previousCell = this.#previousCell(from);\r\n            while (previousCell && previousCell !== to) {\r\n                range.push(previousCell);\r\n                previousCell = this.#previousRow(previousCell);\r\n            }\r\n            range.push(to);\r\n            return range;\r\n        }\r\n        return [];\r\n    }\r\n\r\n    #getRowsRange(from: HTMLElement, to: HTMLElement): HTMLElement[] {\r\n        if (from == to) {\r\n            return [from];\r\n        }\r\n        const position = from.compareDocumentPosition(to);\r\n        if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\r\n            const range = [from];\r\n            let nextRow = this.#nextRow(from);\r\n            while (nextRow && nextRow !== to) {\r\n                range.push(nextRow);\r\n                nextRow = this.#nextRow(nextRow);\r\n            }\r\n            range.push(to);\r\n            return range;\r\n        }\r\n        else if (position & Node.DOCUMENT_POSITION_PRECEDING) {\r\n            const range = [from];\r\n            let previousRow = this.#previousRow(from);\r\n            while (previousRow && previousRow !== to) {\r\n                range.push(previousRow);\r\n                previousRow = this.#previousRow(previousRow);\r\n            }\r\n            range.push(to);\r\n            return range;\r\n        }\r\n        return [];\r\n    }\r\n\r\n    #setCellsSelection(grid: HTMLElement, ...cells: HTMLElement[]): void {\r\n        this.beginSelection(grid);\r\n        const selectedCells = this.selectedCells(grid);\r\n        selectedCells.forEach((selectedCell_i) => {\r\n            if (!cells.includes(selectedCell_i)) {\r\n                gridCellWidget.setSelected(selectedCell_i, false);\r\n            }\r\n        });\r\n        cells.forEach((cell_i) => {\r\n            const selected = gridCellWidget.getSelected(cell_i);\r\n            if (!selected) {\r\n                gridCellWidget.setSelected(cell_i, true);\r\n            }\r\n        });\r\n        this.endSelection(grid);\r\n    }\r\n\r\n    #setRowsSelection(grid: HTMLElement, ...rows: HTMLElement[]): void {\r\n        this.beginSelection(grid);\r\n        const selectedRows = this.selectedRows(grid);\r\n        selectedRows.forEach((selectedRow_i) => {\r\n            if (!rows.includes(selectedRow_i)) {\r\n                gridRowWidget.setSelected(selectedRow_i, false);\r\n            }\r\n        });\r\n        rows.forEach((row_i) => {\r\n            const selected = gridRowWidget.getSelected(row_i);\r\n            if (!selected) {\r\n                gridRowWidget.setSelected(row_i, true);\r\n            }\r\n        });\r\n        this.endSelection(grid);\r\n    }\r\n\r\n    #addCellsToSelection(grid: HTMLElement, ...cells: HTMLElement[]): void {\r\n        this.beginSelection(grid);\r\n        cells.forEach((cell_i) => {\r\n            const selected = gridCellWidget.getSelected(cell_i);\r\n            if (!selected) {\r\n                gridCellWidget.setSelected(cell_i, true);\r\n            }\r\n        });\r\n        this.endSelection(grid);\r\n    }\r\n\r\n    #addRowsToSelection(grid: HTMLElement, ...rows: HTMLElement[]): void {\r\n        this.beginSelection(grid);\r\n        rows.forEach((row_i) => {\r\n            const selected = gridRowWidget.getSelected(row_i);\r\n            if (!selected) {\r\n                gridRowWidget.setSelected(row_i, true);\r\n            }\r\n        });\r\n        this.endSelection(grid);\r\n    }\r\n\r\n    #removeCellsFromSelection(grid: HTMLElement, ...cells: HTMLElement[]): void {\r\n        this.beginSelection(grid);\r\n        const selectedCells = this.selectedCells(grid);\r\n        cells.forEach((cell_i) => {\r\n            if (selectedCells.includes(cell_i)) {\r\n                gridCellWidget.setSelected(cell_i, false);\r\n            }\r\n        });\r\n        this.endSelection(grid);\r\n    }\r\n\r\n    #removeRowsFromSelection(grid: HTMLElement, ...rows: HTMLElement[]): void {\r\n        this.beginSelection(grid);\r\n        const selectedRows = this.selectedRows(grid);\r\n        rows.forEach((row_i) => {\r\n            if (selectedRows.includes(row_i)) {\r\n                gridRowWidget.setSelected(row_i, false);\r\n            }\r\n        });\r\n        this.endSelection(grid);\r\n    }\r\n\r\n    #clearCellsSelection(grid: HTMLElement): void {\r\n        this.beginSelection(grid);\r\n        const selectedCells = this.selectedCells(grid);\r\n        selectedCells.forEach((cell_i) => {\r\n            const selected = gridCellWidget.getSelected(cell_i);\r\n            if (selected) {\r\n                gridCellWidget.setSelected(cell_i, false);\r\n            }\r\n        });\r\n        this.endSelection(grid);\r\n    }\r\n\r\n    #clearRowsSelection(grid: HTMLElement): void {\r\n        this.beginSelection(grid);\r\n        const selectedRows = this.selectedRows(grid);\r\n        selectedRows.forEach((row_i) => {\r\n            const selected = gridRowWidget.getSelected(row_i);\r\n            if (selected) {\r\n                gridRowWidget.setSelected(row_i, false);\r\n            }\r\n        });\r\n        this.endSelection(grid);\r\n    }\r\n\r\n    #setActiveCell(grid: HTMLElement, cell: HTMLElement | null): void {\r\n        const activeCell = this.#getActiveCell(grid);\r\n        if (activeCell !== null && activeCell !== cell) {\r\n            gridCellWidget.setActive(activeCell, false);\r\n            activeCell.tabIndex = -1;\r\n        }\r\n        if (cell !== null) {\r\n            gridCellWidget.setActive(cell, true);\r\n            cell.tabIndex = 0;\r\n        }\r\n    }\r\n\r\n    #setActiveRow(grid: HTMLElement, row: HTMLElement | null): void {\r\n        const activeRow = this.#getActiveRow(grid);\r\n        if (activeRow !== null && activeRow !== row) {\r\n            gridRowWidget.setActive(activeRow, false);\r\n            activeRow.tabIndex = -1;\r\n        }\r\n        if (row !== null) {\r\n            gridCellWidget.setActive(row, true);\r\n            row.tabIndex = 0;\r\n        }\r\n    }\r\n\r\n    #firstCell(row: HTMLElement): HTMLElement | null {\r\n        const cellsWalker = this.#cellsWalker;\r\n        cellsWalker.currentNode = row;\r\n        return <HTMLElement | null>cellsWalker.firstChild();\r\n    }\r\n\r\n    #lastCell(row: HTMLElement): HTMLElement | null {\r\n        const cellsWalker = this.#cellsWalker;\r\n        cellsWalker.currentNode = row;\r\n        return <HTMLElement | null>cellsWalker.lastChild();\r\n    }\r\n\r\n    #previousCell(cell: HTMLElement): HTMLElement | null {\r\n        const cellsWalker = this.#cellsWalker;\r\n        cellsWalker.currentNode = cell;\r\n        return <HTMLElement | null>cellsWalker.previousNode();\r\n    }\r\n\r\n    #nextCell(cell: HTMLElement): HTMLElement | null {\r\n        const cellsWalker = this.#cellsWalker;\r\n        cellsWalker.currentNode = cell;\r\n        return <HTMLElement | null>cellsWalker.nextNode();\r\n    }\r\n\r\n    #closestRow(cell: HTMLElement): HTMLElement | null {\r\n        const rowsWalker = this.#rowsWalker;\r\n        rowsWalker.currentNode = cell;\r\n        return <HTMLElement | null>rowsWalker.parentNode();\r\n    }\r\n\r\n    #firstRow(grid: HTMLElement): HTMLElement | null {\r\n        const rowsWalker = this.#rowsWalker;\r\n        rowsWalker.currentNode = grid;\r\n        return <HTMLElement | null>rowsWalker.firstChild();\r\n    }\r\n\r\n    #lastRow(grid: HTMLElement): HTMLElement | null {\r\n        const rowsWalker = this.#rowsWalker;\r\n        rowsWalker.currentNode = grid;\r\n        return <HTMLElement | null>rowsWalker.lastChild();\r\n    }\r\n\r\n    #previousRow(row: HTMLElement): HTMLElement | null {\r\n        const rowsWalker = this.#rowsWalker;\r\n        rowsWalker.currentNode = row;\r\n        return <HTMLElement | null>rowsWalker.previousNode();\r\n    }\r\n\r\n    #nextRow(row: HTMLElement): HTMLElement | null {\r\n        const rowsWalker = this.#rowsWalker;\r\n        rowsWalker.currentNode = row;\r\n        return <HTMLElement | null>rowsWalker.nextNode();\r\n    }\r\n\r\n    #topCell(cell: HTMLElement): HTMLElement | null {\r\n        const closestRow = this.#closestRow(cell);\r\n        if (closestRow) {\r\n            const closestRowCells = gridRowWidget.cells(closestRow);\r\n            const cellIndex = Array.from(closestRowCells.values()).indexOf(cell);\r\n            const previousRow = this.#previousRow(closestRow);\r\n            if (previousRow) {\r\n                const previousRowCells = gridRowWidget.cells(previousRow);\r\n                return previousRowCells[Math.min(cellIndex, previousRowCells.length)];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    #bottomCell(cell: HTMLElement): HTMLElement | null {\r\n        const closestRow = this.#closestRow(cell);\r\n        if (closestRow) {\r\n            const closestRowCells = gridRowWidget.cells(closestRow);\r\n            const cellIndex = Array.from(closestRowCells.values()).indexOf(cell);\r\n            const nextRow = this.#nextRow(closestRow);\r\n            if (nextRow) {\r\n                const nextRowCells = gridRowWidget.cells(nextRow);\r\n                return nextRowCells[Math.min(cellIndex, nextRowCells.length)];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /*#handleContextMenuEvent(event: MouseEvent) {\r\n        const {currentTarget, target} = event;\r\n        const targetGrid = <HTMLElement>currentTarget;\r\n        const selectby = this.getSelectBy(targetGrid);\r\n        switch (selectby) {\r\n            case \"cell\": {\r\n                const targetCell = (<HTMLElement>target).closest<HTMLElement>(\".gridcell\");\r\n                if (targetCell) {\r\n                    const selectedCells = this.selectedCells(targetGrid);\r\n                    if (!selectedCells.includes(targetCell)) {\r\n                        this.#setCellsSelection(targetCell);\r\n                    }\r\n                    targetCell.focus({preventScroll: true});\r\n                    event.preventDefault();\r\n                }\r\n                break;\r\n            }\r\n            case \"row\": {\r\n                const targetRow = (<HTMLElement>target).closest<HTMLElement>(\".gridrow\");\r\n                if (targetRow) {\r\n                    const selectedRows = this.selectedRows(targetGrid);\r\n                    if (!selectedRows.includes(targetRow)) {\r\n                        this.#setRowsSelection(targetRow);\r\n                    }\r\n                    targetRow.focus({preventScroll: true});\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        event.preventDefault();\r\n    }*/\r\n\r\n    /*#handleDragEndEvent(event: DragEvent): void {\r\n        const {currentTarget} = event;\r\n        const targetTree = <HTMLElement>currentTarget;\r\n        this.#setDropTargetItem(targetTree, null);\r\n    }\r\n\r\n    #handleDragEnterEvent(event: DragEvent): void {\r\n        const {currentTarget, target} = event;\r\n        const targetItem = <HTMLElement | null>(<HTMLElement>target).closest(\".treeitem\");\r\n        const targetTree = <HTMLElement>currentTarget;\r\n        if (targetItem) {\r\n            const type = treeitemWidget.getType(targetItem);\r\n            if (type == \"parent\") {\r\n                treeitemWidget.toggle(targetItem, true);\r\n            }\r\n            this.#setDropTargetItem(targetTree, targetItem);\r\n        }\r\n        event.preventDefault();\r\n    }\r\n\r\n    #handleDragOverEvent(event: DragEvent): void {\r\n        event.preventDefault();\r\n    }\r\n\r\n    #handleDragLeaveEvent(event: DragEvent): void {\r\n        const {currentTarget, relatedTarget} = event;\r\n        const targetTree = <HTMLElement>currentTarget;\r\n        if (relatedTarget) {\r\n            const relatedTargetRoot = (<Node>relatedTarget).getRootNode();\r\n            const relatedTargetHost =\r\n                relatedTargetRoot instanceof ShadowRoot ?\r\n                relatedTargetRoot.host :\r\n                relatedTarget;\r\n            if (!targetTree.contains(<Node>relatedTargetHost)) {\r\n                this.#setDropTargetItem(targetTree, null);\r\n            }\r\n        }\r\n    }\r\n\r\n    #handleDropEvent(event: DragEvent): void {\r\n        const {currentTarget} = event;\r\n        const targetTree = <HTMLElement>currentTarget;\r\n        this.#setDropTargetItem(targetTree, null);\r\n    }*/\r\n\r\n    #handleFocusEvent(event: FocusEvent): void {\r\n        const {currentTarget, relatedTarget} = event;\r\n        const targetGrid = <HTMLElement>currentTarget;\r\n        const selectby = this.getSelectBy(targetGrid);\r\n        switch (selectby) {\r\n            case \"cell\": {\r\n                const activeCell = this.#getActiveCell(targetGrid);\r\n                if (activeCell && relatedTarget !== activeCell) {\r\n                    activeCell.focus();\r\n                }\r\n                break;\r\n            }\r\n            case \"row\": {\r\n                const activeRow = this.#getActiveRow(targetGrid);\r\n                if (activeRow && relatedTarget !== activeRow) {\r\n                    activeRow.focus();\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    #handleFocusInEvent(event: FocusEvent): void {\r\n        const {currentTarget, target} = event;\r\n        const targetGrid = <HTMLElement>currentTarget;\r\n        const selectby = this.getSelectBy(targetGrid);\r\n        switch (selectby) {\r\n            case \"cell\": {\r\n                const targetCell = (<HTMLElement>target).closest<HTMLElement>(\".gridcell\");\r\n                if (targetCell) {\r\n                    this.#setActiveCell(targetGrid, targetCell);\r\n                }\r\n                break;\r\n            }\r\n            case \"row\": {\r\n                const targetRow = (<HTMLElement>target).closest<HTMLElement>(\".gridrow\");\r\n                if (targetRow) {\r\n                    this.#setActiveRow(targetGrid, targetRow);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    #handleFocusOutEvent(event: FocusEvent): void {\r\n        const {currentTarget, relatedTarget} = event;\r\n        const targetGrid = <HTMLElement>currentTarget;\r\n        const lostFocusWithin = !targetGrid.contains(<Node>relatedTarget);\r\n        if (lostFocusWithin) {\r\n            targetGrid.tabIndex = 0;\r\n        }\r\n    }\r\n\r\n    #handleKeyDownEvent(event: KeyboardEvent) {\r\n        const {currentTarget, key} = event;\r\n        const targetGrid = <HTMLElement>currentTarget;\r\n        const activeCell = this.#getActiveCell(targetGrid);\r\n        const activeRow = this.#getActiveRow(targetGrid);\r\n        const selectby = this.getSelectBy(targetGrid);\r\n        const multiselectable = this.getMultiSelectable(targetGrid);\r\n        switch (key) {\r\n            case \"a\": {\r\n                const {ctrlKey} = event;\r\n                if (ctrlKey && multiselectable) {\r\n                    switch (selectby) {\r\n                        case \"cell\": {\r\n                            const firstRow = this.#firstRow(targetGrid);\r\n                            const firstCell = firstRow ? this.#firstCell(firstRow) : null;\r\n                            const lastRow = this.#lastRow(targetGrid);\r\n                            const lastCell = lastRow ? this.#lastCell(lastRow) : null;\r\n                            if (firstCell && lastCell) {\r\n                                const range = this.#getCellsRange(firstCell, lastCell);\r\n                                if (range) {\r\n                                    this.#setCellsSelection(targetGrid, ...range);\r\n                                }\r\n                            }\r\n                            break;\r\n                        }\r\n                        case \"row\": {\r\n                            const firstRow = this.#firstRow(targetGrid);\r\n                            const lastRow = this.#lastRow(targetGrid);\r\n                            if (firstRow && lastRow) {\r\n                                const range = this.#getRowsRange(firstRow, lastRow);\r\n                                if (range) {\r\n                                    this.#setRowsSelection(targetGrid, ...range);\r\n                                }\r\n                            }\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                event.preventDefault();\r\n                break;\r\n            }\r\n            case \"ArrowLeft\": {\r\n                if (selectby == \"cell\") {\r\n                    if (activeCell) {\r\n                        const previousCell = this.#previousCell(activeCell);\r\n                        if (previousCell) {\r\n                            previousCell.focus({preventScroll: true});\r\n                            const {shiftKey} = event;\r\n                            if (shiftKey && multiselectable) {\r\n                                const selected = gridCellWidget.getSelected(previousCell);\r\n                                selected ?\r\n                                    this.#removeCellsFromSelection(targetGrid, previousCell) :\r\n                                    this.#addCellsToSelection(targetGrid, previousCell);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                event.stopPropagation();\r\n                break;\r\n            }\r\n            case \"ArrowRight\": {\r\n                if (selectby == \"cell\") {\r\n                    if (activeCell) {\r\n                        const nextCell = this.#nextCell(activeCell);\r\n                        if (nextCell) {\r\n                            nextCell.focus({preventScroll: true});\r\n                            const {shiftKey} = event;\r\n                            if (shiftKey && multiselectable) {\r\n                                const selected = gridCellWidget.getSelected(nextCell);\r\n                                selected ?\r\n                                    this.#removeCellsFromSelection(targetGrid, nextCell) :\r\n                                    this.#addCellsToSelection(targetGrid, nextCell);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                event.stopPropagation();\r\n                break;\r\n            }\r\n            case \"ArrowUp\": {\r\n                switch (selectby) {\r\n                    case \"cell\": {\r\n                        const firstRow = activeRow ?? this.#firstRow(targetGrid);\r\n                        const topCell = activeCell ?\r\n                            this.#topCell(activeCell) :\r\n                            firstRow ?\r\n                            this.#firstCell(firstRow) :\r\n                            null;\r\n                        if (topCell) {\r\n                            topCell.focus({preventScroll: true});\r\n                            const {shiftKey} = event;\r\n                            if (shiftKey && multiselectable) {\r\n                                const selected = gridCellWidget.getSelected(topCell);\r\n                                selected ?\r\n                                    this.#removeCellsFromSelection(targetGrid, topCell) :\r\n                                    this.#addCellsToSelection(targetGrid, topCell);\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                    case \"row\": {\r\n                        const previousRow = activeRow ?\r\n                            this.#previousRow(activeRow) :\r\n                            this.#firstRow(targetGrid);\r\n                        if (previousRow) {\r\n                            previousRow.focus({preventScroll: true});\r\n                            const {shiftKey} = event;\r\n                            if (shiftKey && multiselectable) {\r\n                                const selected = gridRowWidget.getSelected(previousRow);\r\n                                selected ?\r\n                                    this.#removeRowsFromSelection(targetGrid, previousRow) :\r\n                                    this.#addRowsToSelection(targetGrid, previousRow);\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                event.stopPropagation();\r\n                break;\r\n            }\r\n            case \"ArrowDown\": {\r\n                switch (selectby) {\r\n                    case \"cell\": {\r\n                        const lastRow = activeRow ?? this.#lastRow(targetGrid);\r\n                        const bottomCell = activeCell ?\r\n                            this.#bottomCell(activeCell) :\r\n                            lastRow ?\r\n                            this.#lastCell(lastRow) :\r\n                            null;\r\n                            if (bottomCell) {\r\n                                bottomCell.focus({preventScroll: true});\r\n                                const {shiftKey} = event;\r\n                                if (shiftKey && multiselectable) {\r\n                                    const selected = gridCellWidget.getSelected(bottomCell);\r\n                                    selected ?\r\n                                        this.#removeCellsFromSelection(targetGrid, bottomCell) :\r\n                                        this.#addCellsToSelection(targetGrid, bottomCell);\r\n                                }\r\n                            }\r\n                        }\r\n                        break;\r\n                    case \"row\": {\r\n                        const nextRow = activeRow ?\r\n                            this.#nextRow(activeRow) :\r\n                            this.#lastRow(targetGrid);\r\n                        if (nextRow) {\r\n                            nextRow.focus({preventScroll: true});\r\n                            const {shiftKey} = event;\r\n                            if (shiftKey && multiselectable) {\r\n                                const selected = gridRowWidget.getSelected(nextRow);\r\n                                selected ?\r\n                                    this.#removeRowsFromSelection(targetGrid, nextRow) :\r\n                                    this.#addRowsToSelection(targetGrid, nextRow);\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                event.stopPropagation();\r\n                break;\r\n            }\r\n            case \"Home\": {\r\n                switch (selectby) {\r\n                    case \"cell\": {\r\n                        if (activeRow) {\r\n                            const firstCell = this.#firstCell(activeRow);\r\n                            if (firstCell) {\r\n                                firstCell.focus({preventScroll: true});\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                    case \"row\": {\r\n                        const firstRow = this.#firstRow(targetGrid);\r\n                        if (firstRow) {\r\n                            firstRow.focus({preventScroll: true});\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                event.stopPropagation();\r\n                break;\r\n            }\r\n            case \"End\": {\r\n                switch (selectby) {\r\n                    case \"cell\": {\r\n                        if (activeRow) {\r\n                            const lastCell = this.#lastCell(activeRow);\r\n                            if (lastCell) {\r\n                                lastCell.focus({preventScroll: true});\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                    case \"row\": {\r\n                        const lastRow = this.#lastRow(targetGrid);\r\n                        if (lastRow) {\r\n                            lastRow.focus({preventScroll: true});\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                event.stopPropagation();\r\n                break;\r\n            }\r\n            case \"Enter\": {\r\n                switch (selectby) {\r\n                    case \"cell\": {\r\n                        if (activeCell) {\r\n                            this.#setCellsSelection(targetGrid, activeCell);\r\n                            activeCell.click();\r\n                        }\r\n                        break;\r\n                    }\r\n                    case \"row\": {\r\n                        if (activeRow) {\r\n                            this.#setRowsSelection(targetGrid, activeRow);\r\n                            activeRow.click();\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                event.stopPropagation();\r\n                break;\r\n            }\r\n            case \"Escape\": {\r\n                switch (selectby) {\r\n                    case \"cell\": {\r\n                        this.#clearCellsSelection(targetGrid);\r\n                        this.#setActiveCell(targetGrid, null);\r\n                        break;\r\n                    }\r\n                    case \"row\": {\r\n                        this.#clearRowsSelection(targetGrid);\r\n                        this.#setActiveRow(targetGrid, null);\r\n                        break;\r\n                    }\r\n                }\r\n                targetGrid.focus();\r\n                event.stopPropagation();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    #handleMouseDownEvent(event: MouseEvent): void {\r\n        const {currentTarget, target, ctrlKey, shiftKey} = event;\r\n        const targetGrid = <HTMLElement>currentTarget;\r\n        const selectby = this.getSelectBy(targetGrid);\r\n        const multiselectable = this.getMultiSelectable(targetGrid);\r\n        switch (selectby) {\r\n            case \"cell\": {\r\n                const targetCell = (<HTMLElement>target).closest<HTMLElement>(\".gridcell\");\r\n                if (targetCell) {\r\n                    if (multiselectable) {\r\n                        if (!shiftKey && !ctrlKey) {\r\n                            this.#setCellsSelection(targetGrid, targetCell);\r\n                        }\r\n                        else if (ctrlKey) {\r\n                            const selected = gridCellWidget.getSelected(targetCell);\r\n                            !selected ?\r\n                                this.#addCellsToSelection(targetGrid, targetCell) :\r\n                                this.#removeCellsFromSelection(targetGrid, targetCell);\r\n                            event.stopPropagation();\r\n                        }\r\n                        else if (shiftKey) {\r\n                            const activeCell = this.#getActiveCell(targetGrid);\r\n                            if (activeCell) {\r\n                                const range = this.#getCellsRange(\r\n                                    activeCell,\r\n                                    targetCell\r\n                                );\r\n                                if (range) {\r\n                                    this.#setCellsSelection(targetGrid, ...range);\r\n                                }\r\n                            }\r\n                            event.stopPropagation();\r\n                        }\r\n                    }\r\n                    else {\r\n                        this.#setCellsSelection(targetGrid, targetCell);\r\n                    }\r\n                    event.stopPropagation();\r\n                }\r\n                break;\r\n            }\r\n            case \"row\": {\r\n                const targetRow = (<HTMLElement>target).closest<HTMLElement>(\".gridrow\");\r\n                if (targetRow) {\r\n                    if (multiselectable) {\r\n                        if (!shiftKey && !ctrlKey) {\r\n                            this.#setRowsSelection(targetGrid, targetRow);\r\n                        }\r\n                        else if (ctrlKey) {\r\n                            const selected = gridRowWidget.getSelected(targetRow);\r\n                            !selected ?\r\n                                this.#addRowsToSelection(targetGrid, targetRow) :\r\n                                this.#removeRowsFromSelection(targetGrid, targetRow);\r\n                            event.stopPropagation();\r\n                        }\r\n                        else if (shiftKey) {\r\n                            const activeRow = this.#getActiveRow(targetGrid);\r\n                            if (activeRow) {\r\n                                const range = this.#getRowsRange(\r\n                                    activeRow,\r\n                                    targetRow\r\n                                );\r\n                                if (range) {\r\n                                    this.#setRowsSelection(targetGrid, ...range);\r\n                                }\r\n                            }\r\n                            event.stopPropagation();\r\n                        }\r\n                    }\r\n                    else {\r\n                        this.#setRowsSelection(targetGrid, targetRow);\r\n                    }\r\n                    event.stopPropagation();\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    #handleSelectEvent(event: Event): void {\r\n        const {currentTarget} = event;\r\n        const targetList = <HTMLElement>currentTarget;\r\n        if (targetList) {\r\n            if (this.#onSelection.get(targetList)) {\r\n                this.#hasSelectionChanged.set(targetList, true);\r\n            }\r\n            else {\r\n                targetList.dispatchEvent(new Event(\"selectionchange\", {bubbles: true}));\r\n            }\r\n        }\r\n    }\r\n}));"],"names":["element","tagName","init","options","attributes","dataset","children","listeners","document","createElement","Object","entries","forEach","attributeName","attributeValue","undefined","toggleAttribute","setAttribute","String","elementDataset","keys","datasetEntry_i","append","Array","from","name_i","listener_i","isArray","addEventListener","reactiveElementsMap","WeakMap","FinalizationRegistry","heldValue","model","reactiveElement","reactiveElementsMapEntry","get","reactiveElementsArray","splice","indexOf","records","record_i","target","propertyName","oldValue","newValue","reactiveElement_i","elementRef","react","properties","deref","includes","reactiveChildElementsMap","list","reactiveChildElement","reactiveChildrenElementsMapEntry","reactiveChildElementsArray","range","values","length","listLength","reactiveChildElements_i","parentRef","mapping","placeholder","parent","firstChild","childrenCount","removeChild","changeType","LIST_INSERT","LIST_REMOVE","LIST_SORT","insertedIndex","insertedItems","insertedItemsArray","map","before","removedIndex","removedItems","removedCount","createRange","removeEndIndex","setStartBefore","setEndAfter","deleteContents","sortedIndices","childrenArray","filter","index_i","camelToTrain","str","replace","toLowerCase","ModelChangeRecordBase","constructor","this","ModelNodesList","PROPERTY_CHANGE","ModelChangeRecord","items","slice","item","index","ModelEventBase","type","currentTarget","ModelEventTargetAccessor","setCurrentTarget","event","setTarget","ModelEvent","ModelEventTargetBase","Map","receiveEvent","callbacks","callback_i","callback","push","set","removeEventListener","callbackIndex","findIndex","delete","dispatchEvent","ModelNodeBase","super","parentNode","setParent","isCyclicReference","ancestorNode","TypeError","beginChanges","endChanges","getRecords","property","record","ModelNodeRecordsAccessor","triggerChange","node","handleRecord","ModelNode","ModelObjectBase","ModelObjectPropertiesAccessor","setProperty","value","getProperty","ModelList","item_i","sort","compareFunction","indexedItems","i","indexedItem_a","indexedItem_b","indexedItem_i","prepend","_items","insert","Math","abs","remove","clear","removedItem_i","reference","propertiesFilter","childList","subtree","ModelChangeObserver","observe","references","listener","bind","unobserve","disconnect","slotsMap","slotsObserver","MutationObserver","mutationsList","mutation","HTMLElement","slotReferences","slotRef_i","widget","slot","slottedCallback","widgetsMap","attributesObserver","attributeChangedCallback","getAttribute","WidgetFactory","create","Proxy","apply","thisArg","argumentsList","Reflect","observedSlots","slotName_i","slotName","slotElement","slot_i","slotReference","WeakRef","observedAttributes","attributeFilter","attributeOldValue","Error","widgets","Widget","name","gridCellWidget","class","role","tabindex","cell","cloneNode","id","classList","tabIndex","disabled","headers","add","setDisabled","setHeaders","setSelected","getHeaders","getLabel","textContent","setLabel","setPosInSet","getPosInSet","posInSet","parseInt","setActive","getActive","contains","setDropTarget","getDropTarget","getDisabled","hasAttribute","Event","bubbles","getSelected","JSON","parse","querySelector","gridRowWidget","row","cells","querySelectorAll","childNodes","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","d","definition","key","o","defineProperty","enumerable","obj","prop","prototype","hasOwnProperty","call","gridWidget","createTreeWalker","NodeFilter","SHOW_ELEMENT","grid","rows","selectby","multisectable","setSelectBy","setMultiSelectable","getMultiSelectable","getSelectBy","beginSelection","endSelection","clearSelection","selectedCells","selectedRows","hidden","FILTER_ACCEPT","FILTER_SKIP","FILTER_REJECT","to","position","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","nextCell","DOCUMENT_POSITION_PRECEDING","previousCell","nextRow","previousRow","selectedCell_i","cell_i","selectedRow_i","row_i","activeCell","activeRow","cellsWalker","currentNode","lastChild","previousNode","nextNode","rowsWalker","closestRow","closestRowCells","cellIndex","previousRowCells","min","nextRowCells","relatedTarget","targetGrid","focus","targetCell","closest","targetRow","multiselectable","ctrlKey","firstRow","firstCell","lastRow","lastCell","preventDefault","preventScroll","shiftKey","stopPropagation","topCell","bottomCell","click","targetList"],"sourceRoot":""}