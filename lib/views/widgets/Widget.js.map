{"version":3,"file":"views/widgets/Widget.js","mappings":"sBAkBA,SAASA,EAAaC,GACpB,OAAOA,EAAIC,QAAQ,mBAAoB,KAAKC,aAC9C,C,oBCnBIC,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAaE,QAGrB,IAAIC,EAASN,EAAyBE,GAAY,CAGjDG,QAAS,CAAC,GAOX,OAHAE,EAAoBL,GAAUI,EAAQA,EAAOD,QAASJ,GAG/CK,EAAOD,OACf,CCrBAJ,EAAoBO,EAAI,CAACH,EAASI,KACjC,IAAI,IAAIC,KAAOD,EACXR,EAAoBU,EAAEF,EAAYC,KAAST,EAAoBU,EAAEN,EAASK,IAC5EE,OAAOC,eAAeR,EAASK,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDT,EAAoBU,EAAI,CAACK,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,G,0ECwB9EI,EAIG,IAAIC,QACPC,EAAgB,IAAIC,kBACnBC,IACGA,EAAcC,SAASC,IACnB,MAAM,OAACC,EAAM,KAAEC,GAAQF,EACvB,GAAIC,aAAkBE,YAClB,OAAQD,GACJ,IAAK,YAAa,CACd,MAAME,EAAiBV,EAASN,IAAIa,GAChCG,GACAA,EAAeL,SAAQM,IACnB,MAAM,OAACC,EAAM,QAAEC,EAAO,KAAEC,GAAQH,EAC1BI,EAAmBH,EAAgC,gBAC3B,mBAAnBG,GACPA,EAAgBF,EAAQG,QAAST,EAAQO,E,IAIrD,K,KAId,IAING,EAAkD,IAAIhB,QACtDiB,EAAqB,IAAIf,kBACxBC,IACGA,EAAcC,SAASC,IACnB,MAAM,OAACC,EAAM,KAAEC,GAAQF,EACvB,GAAIC,aAAkBE,YAClB,OAAQD,GACJ,IAAK,aAAc,CACf,MAAM,cAACW,EAAa,SAAEC,GAAYd,EAC5BM,EAASK,EAAWvB,IAAIa,GAC9B,GAAIK,EAAQ,CACR,MAAMS,EAA4BT,EAAyC,yBACpC,mBAA5BS,GACPA,EAAyBd,EAAQY,EAAeC,EAAUb,EAAOe,aAAaH,G,CAGtF,K,KAId,IAkENI,EA9DJ,MAEIC,cACI,MAAMZ,EAAwBa,KAC9BA,KAAKC,OAAS,IAAIC,MACdF,KAAKC,OAAQ,CACTE,MAAO,CAACrB,EAAQsB,EAASC,KACrB,MAAMjB,EAAuBkB,QAAQH,MAAMrB,EAAQsB,EAASC,GACtDE,EAAoCpB,EAA8B,cACpEqB,MAAMC,QAAQF,IACAA,EACTG,KAAIC,IACM,CACHC,SAAUD,EACVE,YAAa1B,EAAOE,KAAKD,EAASuB,OAGxC/B,SAAQkC,IACV,MAAM,YAACD,EAAW,SAAED,GAAYE,EAChC,GAAID,EAAa,CACbpC,EAAcsC,QAAQF,EAAa,CAC/BG,WAAW,IAEf,MAAM/B,EAAiBV,EAASN,IAAI4C,GAC9BI,EAAgB,CAAC9B,SAAQC,QAAS,IAAI8B,QAAQ9B,GAAUC,KAAMuB,GAChEJ,MAAMC,QAAQxB,GACdA,EAAekC,KAAKF,GAGpB1C,EAAS6C,IAAIP,EAAa,IAAIL,MAAMS,G,KAKpD,MAAMI,EAAsBlC,EAAmC,mBAS/D,OARIqB,MAAMC,QAAQY,KACd7B,EAAW4B,IAAIhC,EAASD,GACxBM,EAAmBsB,QAAQ3B,EAAS,CAChCkC,YAAY,EACZC,gBAAiBF,EACjBG,mBAAmB,KAGpBpC,CAAO,GAI9B,CAEAa,SACI,MAAM,IAAIwB,MAAM,mCACpB,CAEApC,OACI,OAAO,IACX,CAEIkB,oBACA,MAAO,CAAC,GACZ,GAIAmB,EAAsC,IAAIC,IAoB9C,SAASxC,EACLyC,EAASC,GACT,MAAM1C,EAASuC,EAAQzD,IAAI2D,GAC3B,GAAIzC,EAAQ,CACR,QAAa7B,IAATuE,EAAoB,CACpB,MAAM,WAACC,EAAU,WAAER,EAAU,QAAES,EAAO,QAAEC,EAAO,UAAEC,GAAaJ,EACxDzC,EAAUD,EAAOc,OAAO6B,GAa9B,GAZIR,GACAxD,OAAOoE,QAAQZ,GAAY1C,SAAQ,EAAEc,EAAeyC,WACzB7E,IAAnB6E,IAC8B,kBAAnBA,EACP/C,EAAQgD,iBAAgB,QAAa1C,GAAgByC,GAGrD/C,EAAQiD,cAAa,QAAa3C,GAAgB4C,OAAOH,I,IAKrEJ,EAAS,CACT,MAAOA,QAASQ,GAAkBnD,EAClCtB,OAAO0E,KAAKT,GAASnD,SAAS6D,IAC1BF,EAAeE,GAAkBH,OAAOP,EAAQU,GAAgB,G,CAGxE,GAAIT,EACA,GAAuB,mBAAZA,GAA0BxB,MAAMC,QAAQuB,IAAYA,aAAmBU,UAA+B,iBAAZV,GAAwBA,aAAmBW,KAAM,CAClJ,MAAMtD,EAAOF,EAAOE,KAAKD,EAAS,MAC9BC,IACuB,mBAAZ2C,EACPA,EAAQ3C,GAEgB,iBAAZ2C,GAAwB,WAAYA,EAChD3C,EAAKuD,UAAUpC,MAAMqC,KAAKb,IAG1B3C,EAAKuD,OAAOZ,G,MAKpBlE,OAAOoE,QAAQF,GAASpD,SAAQ,EAAEkC,EAAQkB,MACtC,MAAM3C,EAAOF,EAAOE,KAAKD,EAAS0B,GAC9BzB,IACuB,mBAAZ2C,EACPA,EAAQ3C,GAEgB,iBAAZ2C,GAAwB,WAAYA,EAChD3C,EAAKuD,UAAUpC,MAAMqC,KAAKb,IAG1B3C,EAAKuD,OAAOZ,G,IAgBhC,OAVIC,GACAnE,OAAOoE,QAAQD,GAAWrD,SAAQ,EAAEkE,EAAQC,MACpCvC,MAAMC,QAAQsC,GACd3D,EAAQ4D,iBAAiBF,EAAQC,EAAW,GAAIA,EAAW,IAG3D3D,EAAQ4D,iBAAiBF,EAAQC,E,IAItC3D,C,CAGP,OAAOD,EAAOc,Q,CAGtB,MAAM,IAAIwB,MAAM,kBAAkBG,qDACtC,CAQA,MAAMqB,EAA0B,SAASpB,GAGrC,OACI1C,IAEA,MAAM,KAACyC,GAAQC,EAKf,OAJAH,EAAQN,IACJQ,EACA,IAAIzC,GAEDA,CAAM,CAErB,C","sources":["webpack://editor/./src/elements/Snippets.ts","webpack://editor/webpack/bootstrap","webpack://editor/webpack/runtime/define property getters","webpack://editor/webpack/runtime/hasOwnProperty shorthand","webpack://editor/./src/views/widgets/Widget.ts"],"sourcesContent":["\r\nexport { snakeToCamel };\r\nexport { camelToSnake };\r\nexport { trainToCamel };\r\nexport { camelToTrain };\r\n\r\nfunction snakeToCamel(str: string) {\r\n  return str.split('_').map(str =>  str.charAt(0).toUpperCase() + str.substring(1).toLowerCase()).join(\"\");\r\n}\r\n\r\nfunction camelToSnake(str: string) {\r\n  return str.replace(/(?<!^)(?=[A-Z])/g, '_').toLowerCase();\r\n}\r\n\r\nfunction trainToCamel(str: string) {\r\n  return str.split('-').map(str =>  str.charAt(0).toUpperCase() + str.substring(1).toLowerCase()).join(\"\");\r\n}\r\n\r\nfunction camelToTrain(str: string) {\r\n  return str.replace(/(?<!^)(?=[A-Z])/g, '-').toLowerCase();\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import { ReactiveChildElements } from \"../../elements/Element\";\r\nimport { camelToTrain } from \"../../elements/Snippets\";\r\n\r\nexport { WidgetFactoryConstructor };\r\n\r\nexport { widget };\r\nexport { Widget };\r\nexport { WidgetFactory };\r\nexport { widgets };\r\n\r\ndeclare global {\r\n    interface WidgetNameMap {}\r\n}\r\n\r\ninterface WidgetFactoryConstructor {\r\n    prototype: WidgetFactory;\r\n    new(): WidgetFactory;\r\n}\r\n\r\ninterface WidgetFactory {\r\n    create(properties?: object): HTMLElement;\r\n    slot(root: HTMLElement, name: string | null): HTMLElement | null;\r\n}\r\n\r\nvar slotsMap: WeakMap<HTMLElement, {\r\n    widget: WidgetFactory,\r\n    element: WeakRef<HTMLElement>;\r\n    slot: string | null;\r\n}[]> = new WeakMap();\r\nvar slotsObserver = new MutationObserver(\r\n    (mutationsList: MutationRecord[]) => {\r\n        mutationsList.forEach((mutation: MutationRecord) => {\r\n            const {target, type} = mutation;\r\n            if (target instanceof HTMLElement) {\r\n                switch (type) {\r\n                    case \"childList\": {\r\n                        const slotReferences = slotsMap.get(target);\r\n                        if (slotReferences) {\r\n                            slotReferences.forEach(slotRef_i => {\r\n                                const {widget, element, slot} = slotRef_i;\r\n                                const slottedCallback = (widget as any)[\"slottedCallback\"];\r\n                                if (typeof slottedCallback == \"function\") {\r\n                                    slottedCallback(element.deref(), target, slot);\r\n                                }\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n);\r\n\r\nvar widgetsMap: WeakMap<HTMLElement, WidgetFactory> = new WeakMap();\r\nvar attributesObserver = new MutationObserver(\r\n    (mutationsList: MutationRecord[]) => {\r\n        mutationsList.forEach((mutation: MutationRecord) => {\r\n            const {target, type} = mutation;\r\n            if (target instanceof HTMLElement) {\r\n                switch (type) {\r\n                    case \"attributes\": {\r\n                        const {attributeName, oldValue} = mutation;\r\n                        const widget = widgetsMap.get(target);\r\n                        if (widget) {\r\n                            const attributeChangedCallback = (widget as any)[\"attributeChangedCallback\"];\r\n                            if (typeof attributeChangedCallback == \"function\") {\r\n                                attributeChangedCallback(target, attributeName, oldValue, target.getAttribute(attributeName!));\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n);\r\n\r\nclass WidgetFactoryBase implements WidgetFactory {\r\n\r\n    constructor() {\r\n        const widget = <WidgetFactory>this;\r\n        this.create = new Proxy(\r\n            this.create, {\r\n                apply: (target, thisArg, argumentsList: Parameters<WidgetFactory[\"create\"]>) => {\r\n                    const element = <HTMLElement>Reflect.apply(target, thisArg, argumentsList);\r\n                    const observedSlots = <(string | null)[]>(widget as any)[\"observedSlots\"];\r\n                    if (Array.isArray(observedSlots)) {\r\n                        const slots = observedSlots\r\n                            .map(slotName_i => {\r\n                                return {\r\n                                    slotName: slotName_i,\r\n                                    slotElement: widget.slot(element, slotName_i)\r\n                                };\r\n                            });\r\n                        slots.forEach(slot_i => {\r\n                            const {slotElement, slotName} = slot_i;\r\n                            if (slotElement) {\r\n                                slotsObserver.observe(slotElement, {\r\n                                    childList: true\r\n                                });\r\n                                const slotReferences = slotsMap.get(slotElement);\r\n                                const slotReference = {widget, element: new WeakRef(element), slot: slotName};\r\n                                if (Array.isArray(slotReferences)) {\r\n                                    slotReferences.push(slotReference);\r\n                                }\r\n                                else {\r\n                                    slotsMap.set(slotElement, new Array(slotReference));\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                    const observedAttributes = (widget as any)[\"observedAttributes\"];\r\n                    if (Array.isArray(observedAttributes)) {\r\n                        widgetsMap.set(element, widget);\r\n                        attributesObserver.observe(element, {\r\n                            attributes: true,\r\n                            attributeFilter: observedAttributes,\r\n                            attributeOldValue: true\r\n                        });\r\n                    }\r\n                    return element;\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    create(): HTMLElement {\r\n        throw new Error(`create method is not implemented`);\r\n    }\r\n\r\n    slot(): HTMLElement | null {\r\n        return null;\r\n    }\r\n\r\n    get observedSlots(): string[] {\r\n        return [\"\"];\r\n    }\r\n}\r\n\r\nvar WidgetFactory: WidgetFactoryConstructor = WidgetFactoryBase;\r\nvar widgets: Map<string, WidgetFactory> = new Map();\r\n\r\ninterface WidgetInit<K extends keyof WidgetNameMap> {\r\n    properties?: Parameters<WidgetNameMap[K][\"create\"]>[0],\r\n    attributes?: {\r\n        [name: string]: number | string | boolean\r\n    },\r\n    dataset?: {\r\n        [property: string]: string | number | boolean\r\n    },\r\n    slotted?: {\r\n        [slot: string]: Node | string | (Node | string)[] | NodeList | ReactiveChildElements\r\n    } | (Node | string | (Node | string)[] | NodeList | ReactiveChildElements),\r\n    listeners?: {\r\n        [EventName in keyof HTMLElementEventMap]?: EventListenerOrEventListenerObject | [EventListenerOrEventListenerObject, boolean | AddEventListenerOptions | undefined]\r\n    }\r\n}\r\n\r\nfunction widget<K extends keyof WidgetNameMap>(\r\n    name: K, init?: WidgetInit<K>): ReturnType<WidgetNameMap[K][\"create\"]>;\r\nfunction widget<K extends keyof WidgetNameMap>(\r\n    name: K, init?: WidgetInit<K>): HTMLElement {\r\n    const widget = widgets.get(name);\r\n    if (widget) {\r\n        if (init !== undefined) {\r\n            const {properties, attributes, dataset, slotted, listeners} = init;\r\n            const element = widget.create(properties);\r\n            if (attributes) {\r\n                Object.entries(attributes).forEach(([attributeName, attributeValue]) => {\r\n                    if (attributeValue !== undefined) {\r\n                        if (typeof attributeValue === \"boolean\") {\r\n                            element.toggleAttribute(camelToTrain(attributeName), attributeValue);\r\n                        }\r\n                        else {\r\n                            element.setAttribute(camelToTrain(attributeName), String(attributeValue));\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            if (dataset) {\r\n                const {dataset: elementDataset} = element;\r\n                Object.keys(dataset).forEach((datasetEntry_i) => {\r\n                    elementDataset[datasetEntry_i] = String(dataset[datasetEntry_i]);\r\n                });\r\n            }\r\n            if (slotted) {\r\n                if (typeof slotted === \"function\" || Array.isArray(slotted) || slotted instanceof NodeList || typeof slotted === \"string\" || slotted instanceof Node) {\r\n                    const slot = widget.slot(element, null);\r\n                    if (slot) {\r\n                        if (typeof slotted === \"function\") {\r\n                            slotted(slot);\r\n                        }\r\n                        else if (typeof slotted === \"object\" && \"length\" in slotted) {\r\n                            slot.append(...Array.from(slotted));\r\n                        }\r\n                        else {\r\n                            slot.append(slotted);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    Object.entries(slotted).forEach(([slot_i, slotted]) => {\r\n                        const slot = widget.slot(element, slot_i);\r\n                        if (slot) {\r\n                            if (typeof slotted === \"function\") {\r\n                                slotted(slot);\r\n                            }\r\n                            else if (typeof slotted === \"object\" && \"length\" in slotted) {\r\n                                slot.append(...Array.from(slotted));\r\n                            }\r\n                            else {\r\n                                slot.append(slotted);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            if (listeners) {\r\n                Object.entries(listeners).forEach(([name_i, listener_i]) => {\r\n                    if (Array.isArray(listener_i)) {\r\n                        element.addEventListener(name_i, listener_i[0], listener_i[1]);\r\n                    }\r\n                    else {\r\n                        element.addEventListener(name_i, listener_i);\r\n                    }\r\n                });\r\n            }\r\n            return element;\r\n        }\r\n        else {\r\n            return widget.create();\r\n        }\r\n    }\r\n    throw new Error(`Unknown widget ${name}. The corresponding module might not be imported.`);\r\n}\r\n\r\ninterface WidgetDecorator {\r\n    (init: {\r\n        name: string;\r\n    }): <W extends WidgetFactoryConstructor>(widget: W) => W;\r\n}\r\n\r\nconst Widget: WidgetDecorator = function(init: {\r\n    name: string;\r\n}) {\r\n    return <W extends WidgetFactoryConstructor>(\r\n        widget: W\r\n    ) => {\r\n        const {name} = init;\r\n        widgets.set(\r\n            name,\r\n            new widget()\r\n        );\r\n        return widget;\r\n    }\r\n}"],"names":["camelToTrain","str","replace","toLowerCase","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","slotsMap","WeakMap","slotsObserver","MutationObserver","mutationsList","forEach","mutation","target","type","HTMLElement","slotReferences","slotRef_i","widget","element","slot","slottedCallback","deref","widgetsMap","attributesObserver","attributeName","oldValue","attributeChangedCallback","getAttribute","WidgetFactory","constructor","this","create","Proxy","apply","thisArg","argumentsList","Reflect","observedSlots","Array","isArray","map","slotName_i","slotName","slotElement","slot_i","observe","childList","slotReference","WeakRef","push","set","observedAttributes","attributes","attributeFilter","attributeOldValue","Error","widgets","Map","name","init","properties","dataset","slotted","listeners","entries","attributeValue","toggleAttribute","setAttribute","String","elementDataset","keys","datasetEntry_i","NodeList","Node","append","from","name_i","listener_i","addEventListener","Widget"],"sourceRoot":""}