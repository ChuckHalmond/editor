{"version":3,"file":"observers/NodeCollection.ts.js","mappings":"mBACA,I,wvBC8DK,WAEmBA,GAChB,MAAMC,EAAW,EAAAC,KAAI,OACrBD,EAASE,aACT,EAAAD,KAAI,OAAkBE,QAAQJ,GAC9B,EAAAE,KAAI,OAAkBG,SAASC,IAC3BL,EAASM,QAAQD,EAAS,CACtBE,WAAW,GACb,GAEV,EAAC,WAEsBR,GACnB,MAAMC,EAAW,EAAAC,KAAI,OACrBD,EAASE,aACT,EAAAD,KAAI,EAAoB,EAAAA,KAAI,OAAkBO,QAAOC,IAAaV,EAAQW,SAASD,KAAU,KAC7F,EAAAR,KAAI,OAAkBG,SAASC,IAC3BL,EAASM,QAAQD,EAAS,CACtBE,WAAW,GACb,GAEV,EAAC,aAEiBI,GACd,GAAIA,EAAMC,OAAS,EAAG,CAClB,MAAMJ,EAAS,EAAAP,KAAI,OACbY,EAA+B,mBAAXL,EAAwBA,EAASA,EAAOK,WAC5DC,EAAkB,GAClBC,EAA+B,GACrCJ,EAAMP,SAASY,IAEX,OADyBH,EAAWG,IAEhC,KAAKC,WAAWC,cACZJ,EAAWX,KAAQa,GACnB,MAEJ,KAAKC,WAAWE,YACZJ,EAAqBZ,KAAKa,G,IAKlCD,EAAqBH,OAAS,IAC9B,EAAAX,KAAI,SAAoB,KAAxBA,KAAyBc,GACzBA,EAAqBX,SAASK,IAC1B,EAAAR,KAAI,SAAkB,KAAtBA,KAAuBQ,EAASW,WAAW,KAG/CN,EAAWF,OAAS,GACpBE,EAAWV,SAASiB,IAChB,MAAMC,EAAQ,EAAArB,KAAI,OAAQsB,WACtBF,GAAUA,EAAOG,wBAAwBH,GAAUI,KAAKC,8BAE5D,EAAAzB,KAAI,OAAQ0B,OAAOL,GAAS,EAAIA,EAAQ,EAAG,EAAGD,EAAO,G,CAIrE,EAAC,aAEmBV,GAChB,GAAIA,EAAMC,OAAS,EAAG,CAClB,MAAMJ,EAAS,EAAAP,KAAI,OACbY,EAA+B,mBAAXL,EAAwBA,EAASA,EAAOK,WAC5De,EAAoB,GACpBC,EAAiC,GACvClB,EAAMP,SAASY,IAEX,OADyBH,EAAWG,IAEhC,KAAKC,WAAWC,cACZU,EAAazB,KAAQa,GACrB,MAEJ,KAAKC,WAAWE,YACZU,EAAuB1B,KAAKa,G,IAKpCa,EAAuBjB,OAAS,IAChC,EAAAX,KAAI,SAAuB,KAA3BA,KAA4B4B,GAC5BA,EAAuBzB,SAASK,IAC5B,EAAAR,KAAI,SAAoB,KAAxBA,KAAyBQ,EAASW,WAAW,KAGjDQ,EAAahB,OAAS,GACtB,EAAAX,KAAI,EAAU,EAAAA,KAAI,OAAQO,QAAOa,IAAWO,EAAalB,SAASW,KAAQ,I,CAGtF,C","sources":["webpack://editor/webpack/bootstrap","webpack://editor/./src/observers/NodeCollection.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","export { NodeCollection };\r\n\r\ninterface NodeCollectionConstructor {\r\n    prototype: NodeCollection;\r\n    new(root: Node, filter: NodeFilter): NodeCollection<Node>;\r\n    new<N extends Node>(root: Node, filter: NodeFilter): NodeCollection<N>;\r\n}\r\n\r\ninterface NodeCollection<N extends Node = Node> {\r\n    readonly root: Node;\r\n    readonly filter: NodeFilter;\r\n    readonly length: number;\r\n    item(index: number): N | undefined;\r\n    values(): IterableIterator<N>;\r\n}\r\n\r\nclass NodeCollectionBase<N extends Node = Node> {\r\n    #root: Node;\r\n    #filter: NodeFilter;\r\n    #observer: MutationObserver;\r\n    #observerTargets: Node[];\r\n\r\n    #items: N[];\r\n\r\n    constructor(root: Node, filter: NodeFilter) {\r\n        this.#root = root;\r\n        this.#filter = filter;\r\n        this.#items = [];\r\n        this.#observer = new MutationObserver(\r\n            this.#handleMutationRecords.bind(this)\r\n        );\r\n        this.#observerTargets = [root];\r\n        this.#observer.observe(root, {\r\n            childList: true\r\n        });\r\n        this.#handleAddedNodes(root.childNodes);\r\n    }\r\n\r\n    get root() {\r\n        return this.#root;\r\n    }\r\n\r\n    get filter() {\r\n        return this.#filter;\r\n    }\r\n\r\n    get length() {\r\n        return this.#update(), this.#items.length;\r\n    }\r\n\r\n    item(index: number): N | undefined {\r\n        return this.#update(), this.#items[index];\r\n    }\r\n\r\n    values(): IterableIterator<N> {\r\n        return this.#update(), this.#items.values();\r\n    }\r\n\r\n    #update(): void {\r\n        const records = this.#observer.takeRecords();\r\n        if (records.length > 0) {\r\n            this.#handleMutationRecords(records);\r\n        }\r\n    }\r\n\r\n    #addObserverTargets(targets: Node[]): void {\r\n        const observer = this.#observer;\r\n        observer.disconnect();\r\n        this.#observerTargets.push(...targets);\r\n        this.#observerTargets.forEach((group_i) => {\r\n            observer.observe(group_i, {\r\n                childList: true\r\n            });\r\n        });\r\n    }\r\n\r\n    #removeObserverTargets(targets: Node[]): void {\r\n        const observer = this.#observer;\r\n        observer.disconnect();\r\n        this.#observerTargets = this.#observerTargets.filter(target_i => !targets.includes(target_i));\r\n        this.#observerTargets.forEach((group_i) => {\r\n            observer.observe(group_i, {\r\n                childList: true\r\n            });\r\n        });\r\n    }\r\n\r\n    #handleAddedNodes(nodes: NodeList): void {\r\n        if (nodes.length > 0) {\r\n            const filter = this.#filter;\r\n            const acceptNode = typeof filter === \"function\" ? filter : filter.acceptNode;\r\n            const addedItems = <N[]>[];\r\n            const addedObserverTargets = <Node[]>[];\r\n            nodes.forEach((node: Node) => {\r\n                const acceptNodeResult = acceptNode(node);\r\n                switch (acceptNodeResult) {\r\n                    case NodeFilter.FILTER_ACCEPT: {\r\n                        addedItems.push(<N>node);\r\n                        break;\r\n                    }\r\n                    case NodeFilter.FILTER_SKIP: {\r\n                        addedObserverTargets.push(node);\r\n                        break;\r\n                    }\r\n                }\r\n            });\r\n            if (addedObserverTargets.length > 0) {\r\n                this.#addObserverTargets(addedObserverTargets);\r\n                addedObserverTargets.forEach((target_i) => {\r\n                    this.#handleAddedNodes(target_i.childNodes);\r\n                });\r\n            }\r\n            if (addedItems.length > 0) {\r\n                addedItems.forEach((item_i) => {\r\n                    const index = this.#items.findIndex(\r\n                        item_i => item_i.compareDocumentPosition(item_i) & Node.DOCUMENT_POSITION_FOLLOWING\r\n                    );\r\n                    this.#items.splice(index > -1 ? index : 0, 0, item_i);\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    #handleRemovedNodes(nodes: NodeList): void {\r\n        if (nodes.length > 0) {\r\n            const filter = this.#filter;\r\n            const acceptNode = typeof filter === \"function\" ? filter : filter.acceptNode;\r\n            const removedItems = <N[]>[];\r\n            const removedObserverTargets = <Node[]>[];\r\n            nodes.forEach((node: Node) => {\r\n                const acceptNodeResult = acceptNode(node);\r\n                switch (acceptNodeResult) {\r\n                    case NodeFilter.FILTER_ACCEPT: {\r\n                        removedItems.push(<N>node);\r\n                        break;\r\n                    }\r\n                    case NodeFilter.FILTER_SKIP: {\r\n                        removedObserverTargets.push(node);\r\n                        break;\r\n                    }\r\n                }\r\n            });\r\n            if (removedObserverTargets.length > 0) {\r\n                this.#removeObserverTargets(removedObserverTargets);\r\n                removedObserverTargets.forEach((target_i) => {\r\n                    this.#handleRemovedNodes(target_i.childNodes);\r\n                });\r\n            }\r\n            if (removedItems.length > 0) {\r\n                this.#items = this.#items.filter(item_i => !removedItems.includes(item_i));\r\n            }\r\n        }\r\n    }\r\n\r\n    #handleMutationRecords(mutationsList: MutationRecord[]) {\r\n        mutationsList.forEach((mutation: MutationRecord) => {\r\n            const {addedNodes, removedNodes} = mutation;\r\n            this.#handleRemovedNodes(removedNodes);\r\n            this.#handleAddedNodes(addedNodes);\r\n        });\r\n    }\r\n}\r\n\r\nvar NodeCollection: NodeCollectionConstructor = NodeCollectionBase;"],"names":["targets","observer","this","disconnect","push","forEach","group_i","observe","childList","filter","target_i","includes","nodes","length","acceptNode","addedItems","addedObserverTargets","node","NodeFilter","FILTER_ACCEPT","FILTER_SKIP","childNodes","item_i","index","findIndex","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","splice","removedItems","removedObserverTargets"],"sourceRoot":""}