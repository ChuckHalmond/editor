{"version":3,"file":"models/Model.js","mappings":"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","sources":["webpack://editor/webpack/bootstrap","webpack://editor/./src/models/Model.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","export { ModelChangeRecord };\r\nexport { ModelEvent };\r\nexport { ModelNode };\r\nexport { ModelObject };\r\nexport { ModelProperty };\r\nexport { ModelList };\r\nexport { ModelChangeObserverOptions };\r\nexport { ModelChangeObserver };\r\n\r\ninterface ModelChangeRecordConstructor {\r\n    prototype: ModelChangeRecord;\r\n    new(\r\n        init: {\r\n            target: ModelNode | ModelList;\r\n            changeType: number;\r\n            propertyName?: string;\r\n            oldValue?: any;\r\n            newValue?: any;\r\n            removedIndex?: number,\r\n            removedItems?: ModelNode[],\r\n            insertedIndex?: number,\r\n            insertedItems?: ModelNode[],\r\n            sortedIndices?: number[]\r\n        }\r\n    ): ModelChangeRecord;\r\n    readonly PROPERTY_CHANGE: number;\r\n    readonly LIST_REMOVE: number;\r\n    readonly LIST_INSERT: number;\r\n    readonly LIST_SORT: number;\r\n}\r\n\r\ninterface ModelChangeRecord {\r\n    readonly target: ModelNode | ModelList\r\n    readonly propertyName: string | null;\r\n    readonly oldValue: any;\r\n    readonly newValue: any;\r\n    readonly changeType: number;\r\n    readonly removedIndex: number;\r\n    readonly removedItems: ModelNodesList;\r\n    readonly insertedIndex: number;\r\n    readonly insertedItems: ModelNodesList;\r\n    readonly sortedIndices: number[];\r\n    readonly PROPERTY_CHANGE: number;\r\n    readonly LIST_REMOVE: number;\r\n    readonly LIST_INSERT: number;\r\n    readonly LIST_SORT: number;\r\n}\r\n\r\nclass ModelChangeRecordBase implements ModelChangeRecord {\r\n    readonly target: ModelNode | ModelList;\r\n    readonly changeType: number;\r\n    readonly propertyName: string | null;\r\n    readonly oldValue: any;\r\n    readonly newValue: any;\r\n    readonly removedIndex: number;\r\n    readonly removedItems: ModelNodesList;\r\n    readonly insertedIndex: number;\r\n    readonly insertedItems: ModelNodesList;\r\n    readonly sortedIndices: number[];\r\n\r\n    constructor(\r\n        init: {\r\n            target: ModelNode | ModelList;\r\n            changeType: number;\r\n            propertyName?: string;\r\n            oldValue?: any;\r\n            newValue?: any;\r\n            removedIndex?: number,\r\n            removedItems?: ModelNode[],\r\n            insertedIndex?: number,\r\n            insertedItems?: ModelNode[],\r\n            sortedIndices?: number[]\r\n        }\r\n    ) {\r\n        this.target = init.target;\r\n        this.changeType = init.changeType;\r\n        this.propertyName = init.propertyName ?? null;\r\n        this.oldValue = init.oldValue ?? undefined;\r\n        this.newValue = init.newValue ?? undefined;\r\n        this.removedIndex = init.removedIndex ?? 0;\r\n        this.removedItems = new ModelNodesList(init.removedItems ?? []);\r\n        this.insertedIndex = init.insertedIndex ?? 0;\r\n        this.insertedItems = new ModelNodesList(init.insertedItems ?? []);\r\n        this.sortedIndices = init.sortedIndices ?? [];\r\n    }\r\n\r\n    static get PROPERTY_CHANGE(): number {\r\n        return 1;\r\n    }\r\n\r\n    static get LIST_REMOVE(): number {\r\n        return 2;\r\n    }\r\n\r\n    static get LIST_INSERT(): number {\r\n        return 3;\r\n    }\r\n\r\n    static get LIST_SORT(): number {\r\n        return 4;\r\n    }\r\n\r\n    get PROPERTY_CHANGE(): number {\r\n        return ModelChangeRecordBase.PROPERTY_CHANGE;\r\n    }\r\n\r\n    get LIST_REMOVE(): number {\r\n        return ModelChangeRecordBase.LIST_REMOVE;\r\n    }\r\n\r\n    get LIST_INSERT(): number {\r\n        return ModelChangeRecordBase.LIST_INSERT;\r\n    }\r\n\r\n    get LIST_SORT(): number {\r\n        return ModelChangeRecordBase.LIST_SORT;\r\n    }\r\n}\r\n\r\nvar ModelChangeRecord: ModelChangeRecordConstructor = ModelChangeRecordBase;\r\n\r\ninterface ModelNodesListConstructor {\r\n    prototype: ModelNodesList;\r\n    new(items: any[]): ModelNodesList;\r\n}\r\n\r\ninterface ModelNodesList {\r\n    get length(): number;\r\n    item(index: number): ModelNode | null;\r\n    values(): IterableIterator<ModelNode>;\r\n}\r\n\r\nclass ModelNodesListBase implements ModelNodesList {\r\n    #items: ModelNode[];\r\n\r\n    constructor(items: ModelNode[]) {\r\n        this.#items = items.slice();\r\n    }\r\n\r\n    get length(): number {\r\n        return this.#items.length;\r\n    }\r\n\r\n    item(index: number): ModelNode | null {\r\n        return this.#items[index] ?? null;\r\n    }\r\n\r\n    values(): IterableIterator<ModelNode> {\r\n        return this.#items.values();\r\n    }\r\n}\r\n\r\nvar ModelNodesList: ModelNodesListConstructor = ModelNodesListBase;\r\n\r\ninterface ModelEventConstructor {\r\n    prototype: ModelEvent;\r\n    new(type: string): ModelEvent;\r\n}\r\n\r\ninterface ModelEvent {\r\n    readonly type: string;\r\n    readonly currentTarget: ModelEventTarget | null;\r\n    readonly target: ModelEventTarget | null;\r\n}\r\n\r\nclass ModelEventBase implements ModelEvent {\r\n    readonly type: string;\r\n\r\n    #currentTarget: ModelEventTarget | null;\r\n    #target: ModelEventTarget | null;\r\n\r\n    constructor(type: string) {\r\n        this.type = type;\r\n        this.#currentTarget = null;\r\n        this.#target = null;\r\n    }\r\n\r\n    get currentTarget(): ModelEventTarget | null {\r\n        return this.#currentTarget;\r\n    }\r\n\r\n    get target(): ModelEventTarget | null {\r\n        return this.#target;\r\n    }\r\n\r\n    static ModelEventTargetAccessor? = new class ModelEventTargetAccessor {\r\n        setCurrentTarget(event: ModelEvent, currentTarget: ModelEventTarget): void {\r\n            if (event instanceof ModelEventBase) {\r\n                event.#currentTarget = currentTarget;\r\n            }\r\n        }\r\n\r\n        setTarget(event: ModelEvent, target: ModelEventTarget): void {\r\n            if (event instanceof ModelEventBase) {\r\n                event.#target = target;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface ModelEventTargetAccessor {\r\n    setCurrentTarget(event: ModelEvent, currentTarget: ModelEventTarget): void;\r\n    setTarget(event: ModelEvent, target: ModelEventTarget): void;\r\n}\r\n\r\nvar ModelEventTargetAccessor: ModelEventTargetAccessor = ModelEventBase.ModelEventTargetAccessor!;\r\ndelete ModelEventBase.ModelEventTargetAccessor;\r\n\r\nvar ModelEvent: ModelEventConstructor = ModelEventBase;\r\n\r\ninterface ModelEventTargetConstructor {\r\n    prototype: ModelEventTarget;\r\n    new(): ModelEventTarget;\r\n}\r\n\r\ninterface ModelEventTarget {\r\n    addEventListener(type: string, callback: (event: ModelEvent) => void): void;\r\n    removeEventListener(type: string, callback: (event: ModelEvent) => void): void;\r\n    dispatchEvent(event: ModelEvent): void;\r\n    receiveEvent(event: ModelEvent): void;\r\n}\r\n\r\nclass ModelEventTargetBase implements ModelEventTarget {\r\n    #callbacks: Map<string, ((event: ModelEvent) => void)[]>;\r\n\r\n    constructor() {\r\n        this.#callbacks = new Map();\r\n    }\r\n\r\n    receiveEvent(event: ModelEvent): void {\r\n        const {type} = event;\r\n        const callbacks = this.#callbacks.get(type);\r\n        ModelEventTargetAccessor.setCurrentTarget(event, this);\r\n        if (callbacks) {\r\n            callbacks.forEach((callback_i) => {\r\n                callback_i(event);\r\n            });\r\n        }\r\n    }\r\n\r\n    addEventListener(type: string, callback: (event: ModelEvent) => void): void {\r\n        const callbacks = this.#callbacks.get(type);\r\n        if (callbacks) {\r\n            callbacks.push(callback);\r\n        }\r\n        else {\r\n            this.#callbacks.set(type, [callback]);\r\n        }\r\n    }\r\n\r\n    removeEventListener(type: string, callback: (event: ModelEvent) => void): void {\r\n        const callbacks = this.#callbacks.get(type);\r\n        if (callbacks) {\r\n            const callbackIndex = callbacks.findIndex(\r\n                callback_i => callback_i == callback\r\n            );\r\n            if (callbackIndex > -1) {\r\n                callbacks.splice(callbackIndex, 1);\r\n            }\r\n            if (callbacks.length == 0) {\r\n                this.#callbacks.delete(type);\r\n            }\r\n        }\r\n    }\r\n\r\n    dispatchEvent(event: ModelEvent): void {\r\n        ModelEventTargetAccessor.setTarget(event, this);\r\n        this.receiveEvent(event);\r\n    }\r\n}\r\n\r\nvar ModelEventTarget: ModelEventTargetConstructor = ModelEventTargetBase;\r\n\r\ninterface ModelNodeConstructor {\r\n    prototype: ModelNode;\r\n    new(): ModelNode;\r\n}\r\n\r\ninterface ModelNode extends ModelEventTarget {\r\n    readonly parentNode: ModelNode | null;\r\n    setParent(parentNode: ModelNode | null): void;\r\n    getRecords(): ModelChangeRecord[];\r\n    beginChanges(): void;\r\n    endChanges(): void;\r\n}\r\n\r\ninterface ModelNodeRecordsAccessor {\r\n    triggerChange(node: ModelNode, property: string, oldValue: any, newValue: any): void;\r\n    handleRecord(node: ModelNode, record: ModelChangeRecord): void;\r\n}\r\n\r\nclass ModelNodeBase extends ModelEventTargetBase implements ModelNode {\r\n    #parentNode: ModelNode | null;\r\n    #records: ModelChangeRecord[];\r\n    #isRecording: boolean;\r\n\r\n    constructor() {\r\n        super();\r\n        this.#parentNode = null;\r\n        this.#records = [];\r\n        this.#isRecording = false;\r\n    }\r\n\r\n    get parentNode(): ModelNode | null {\r\n        return this.#parentNode;\r\n    }\r\n\r\n    setParent(parentNode: ModelNode | null): void {\r\n        if (parentNode !== null) {\r\n            let isCyclicReference = parentNode == this;\r\n            let {parentNode: ancestorNode} = parentNode;\r\n            while (!isCyclicReference && ancestorNode !== null) {\r\n                ({parentNode: ancestorNode} = ancestorNode);\r\n                isCyclicReference = ancestorNode == this;\r\n            }\r\n            if (!isCyclicReference) {\r\n                this.#parentNode = parentNode;\r\n            }\r\n            else {\r\n                throw new TypeError(\"Failed to set parent on ModelNode: circular reference detected in the hierarchy.\");\r\n            }\r\n        }\r\n        else {\r\n            this.#parentNode = null;\r\n        }\r\n    }\r\n    \r\n    beginChanges(): void {\r\n        this.#isRecording = true;\r\n    }\r\n\r\n    endChanges(): void {\r\n        this.dispatchEvent(new ModelEvent(\"modelchange\"));\r\n        this.#records.splice(0);\r\n        this.#isRecording = false;\r\n    }\r\n\r\n    getRecords(): ModelChangeRecord[] {\r\n        return this.#records.slice();\r\n    }\r\n\r\n    receiveEvent(event: ModelEvent): void {\r\n        super.receiveEvent(event);\r\n        const {parentNode} = this;\r\n        if (parentNode) {\r\n            parentNode.receiveEvent(event);\r\n        }\r\n    }\r\n\r\n    #triggerChange(property: string, oldValue: any, newValue: any): void {\r\n        const records = this.#records;\r\n        const record = new ModelChangeRecord({\r\n            target: this,\r\n            changeType: ModelChangeRecord.PROPERTY_CHANGE,\r\n            propertyName: property,\r\n            oldValue, newValue\r\n        });\r\n        records.push(record);\r\n        if (!this.#isRecording) {\r\n            this.dispatchEvent(new ModelEvent(\"modelchange\"));\r\n            records.splice(0);\r\n        }\r\n    }\r\n\r\n    #handleRecord(record: ModelChangeRecord): void {\r\n        this.#records.push(record);\r\n        if (!this.#isRecording) {\r\n            this.dispatchEvent(new ModelEvent(\"modelchange\"));\r\n            this.#records.splice(0);\r\n        }\r\n    }\r\n\r\n    static ModelNodeRecordsAccessor? = new class ModelNodeRecordsAccessor {\r\n        triggerChange(node: ModelNode, property: string, oldValue: any, newValue: any): void {\r\n            if (node instanceof ModelNodeBase) {\r\n                node.#triggerChange(property, oldValue, newValue);\r\n            }\r\n        }\r\n\r\n        handleRecord(node: ModelNode, record: ModelChangeRecord): void {\r\n            if (node instanceof ModelNodeBase) {\r\n                node.#handleRecord(record);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvar ModelNodeRecordsAccessor: ModelNodeRecordsAccessor = ModelNodeBase.ModelNodeRecordsAccessor!;\r\ndelete ModelNodeBase.ModelNodeRecordsAccessor;\r\n\r\nvar ModelNode: ModelNodeConstructor = ModelNodeBase;\r\n\r\ninterface ModelPropertyDecorator {\r\n    (): <Model extends ModelObject>(target: Model, property: string) => void;\r\n}\r\n\r\nconst ModelProperty: ModelPropertyDecorator = function() {\r\n    return (\r\n        target: ModelObject, property: string\r\n    ) => {\r\n        const {constructor} = target;\r\n        const {prototype} = constructor;\r\n        const setter = function(this: ModelObject, value: any) {\r\n            const oldValue = ModelObjectPropertiesAccessor.getProperty(this, property);\r\n            ModelObjectPropertiesAccessor.setProperty(this, property, value);\r\n            if (value !== oldValue) {\r\n                ModelNodeRecordsAccessor.triggerChange(this, property, oldValue, value);\r\n            }\r\n            return true;\r\n        };\r\n        const getter = function(this: ModelObject) {\r\n            return ModelObjectPropertiesAccessor.getProperty(this, property);\r\n        };\r\n        Object.defineProperty(prototype, property, {\r\n            set: setter,\r\n            get: getter,\r\n            enumerable: true\r\n        });\r\n    }\r\n}\r\n\r\ninterface ModelObjectConstructor {\r\n    prototype: ModelObject;\r\n    new(): ModelObject;\r\n}\r\n\r\ninterface ModelObject extends ModelNode {}\r\n\r\ninterface ModelObjectPropertiesAccessor {\r\n    setProperty(node: ModelNode, property: string, value: any): void;\r\n    getProperty(node: ModelNode, property: string,): any;\r\n}\r\n\r\nclass ModelObjectBase extends ModelNodeBase implements ModelObject {\r\n    #properties: Map<string, any>;\r\n\r\n    constructor() {\r\n        super();\r\n        this.#properties = new Map();\r\n    }\r\n\r\n    static ModelObjectPropertiesAccessor? = new class ModelPropertiesAccessor {\r\n        setProperty(node: ModelObject, property: string, value: any): void {\r\n            if (node instanceof ModelObjectBase) {\r\n                node.#properties.set(property, value);\r\n            }\r\n        }\r\n\r\n        getProperty(node: ModelObject, property: string): any {\r\n            if (node instanceof ModelObjectBase) {\r\n                return node.#properties.get(property);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvar ModelObjectPropertiesAccessor: ModelObjectPropertiesAccessor = ModelObjectBase.ModelObjectPropertiesAccessor!;\r\ndelete ModelObjectBase.ModelObjectPropertiesAccessor;\r\n\r\nvar ModelObject: ModelObjectConstructor = ModelObjectBase;\r\n\r\ninterface ModelListConstructor {\r\n    prototype: ModelList;\r\n    new<Model extends ModelNode>(): ModelList<Model>;\r\n    new<Model extends ModelNode>(items: Model[]): ModelList<Model>;\r\n}\r\n\r\ninterface ModelList<Model extends ModelNode = ModelNode> extends ModelNode {\r\n    readonly parentNode: ModelNode | null;\r\n    readonly length: number;\r\n    index(item: Model): number;\r\n    get(index: number): Model | null;\r\n    values(): IterableIterator<Model>;\r\n    sort(compareFunction: (item_a: any, item_b: any) => number): void;\r\n    insert(index: number, ...items: Model[]): void;\r\n    prepend(...items: Model[]): void;\r\n    append(...items: Model[]): void;\r\n    remove(item: Model): void;\r\n    clear(): void;\r\n}\r\n\r\nclass ModelListBase<Model extends ModelNode = ModelNode> extends ModelNodeBase implements ModelList<Model> {\r\n    #items: Model[];\r\n\r\n    constructor()\r\n    constructor(items: Model[])\r\n    constructor(items?: Model[]) {\r\n        super();\r\n        this.#items = items?.slice() ?? [];\r\n    }\r\n\r\n    setParent(parentNode: ModelNode | null): void {\r\n        super.setParent(parentNode);\r\n        this.#items.forEach((item_i) => {\r\n            item_i.setParent(parentNode);\r\n        });\r\n    }\r\n\r\n    get length(): number {\r\n        return this.#items.length;\r\n    }\r\n\r\n    get(index: number): Model | null {\r\n        return this.#items[index] ?? null;\r\n    }\r\n\r\n    index(item: Model): number {\r\n        return this.#items.indexOf(item);\r\n    }\r\n\r\n    values(): IterableIterator<Model> {\r\n        return this.#items.values();\r\n    }\r\n\r\n    sort(compareFunction: (item_a: any, item_b: any) => number): void {\r\n        const items = this.#items;\r\n        const indexedItems = items.map(\r\n            (item_i, i) => {\r\n                return {\r\n                    item: item_i,\r\n                    index: i\r\n                };\r\n            }\r\n        );\r\n        indexedItems.sort(\r\n            (indexedItem_a, indexedItem_b) => {\r\n                return compareFunction(\r\n                    indexedItem_a.item, indexedItem_b.item\r\n                )\r\n            }\r\n        );\r\n        this.#items = indexedItems.map(indexedItem_i => indexedItem_i.item);\r\n        const record = new ModelChangeRecord({\r\n            target: this,\r\n            changeType: ModelChangeRecord.LIST_SORT,\r\n            sortedIndices: indexedItems.map(indexedItem_i => indexedItem_i.index)\r\n        });\r\n        ModelNodeRecordsAccessor.handleRecord(this, record);\r\n    }\r\n\r\n    prepend(...items: Model[]): void {\r\n        const _items = this.#items;\r\n        const {parentNode} = this;\r\n        if (parentNode) {\r\n            items.forEach(item_i => {\r\n                item_i.setParent(parentNode);\r\n            });\r\n        }\r\n        _items.splice(0, 0, ...items);\r\n        const record = new ModelChangeRecord({\r\n            target: this,\r\n            changeType: ModelChangeRecord.LIST_INSERT,\r\n            insertedIndex: 0,\r\n            insertedItems: items\r\n        });\r\n        ModelNodeRecordsAccessor.handleRecord(this, record);\r\n    }\r\n\r\n    append(...items: Model[]): void {\r\n        const _items = this.#items;\r\n        const {length} = _items;\r\n        const {parentNode} = this;\r\n        if (parentNode) {\r\n            items.forEach(item_i => {\r\n                item_i.setParent(parentNode);\r\n            });\r\n        }\r\n        _items.push(...items);\r\n        const record = new ModelChangeRecord({\r\n            target: this,\r\n            changeType: ModelChangeRecord.LIST_INSERT,\r\n            insertedIndex: length,\r\n            insertedItems: items\r\n        });\r\n        ModelNodeRecordsAccessor.handleRecord(this, record);\r\n    }\r\n\r\n    insert(index: number, ...items: Model[]): void {\r\n        const _items = this.#items;\r\n        const {length} = _items;\r\n        const positiveIndex = Math.abs(index);\r\n        if (positiveIndex <= length) {\r\n            if (index >= 0) {\r\n                const {parentNode} = this;\r\n                items.forEach(item_i => {\r\n                    item_i.setParent(parentNode);\r\n                });\r\n                if (index < length) {\r\n                    _items.splice(index, 0, ...items);\r\n                }\r\n                else {\r\n                    _items.push(...items);\r\n                }\r\n            }\r\n            else if (index < 0) {\r\n                index = length - index;\r\n                const {parentNode} = this;\r\n                if (parentNode) {\r\n                    items.forEach(item_i => {\r\n                        item_i.setParent(parentNode);\r\n                    });\r\n                }\r\n                _items.splice(index, 0, ...items);\r\n            }\r\n            const record = new ModelChangeRecord({\r\n                target: this,\r\n                changeType: ModelChangeRecord.LIST_INSERT,\r\n                insertedIndex: index,\r\n                insertedItems: items.slice()\r\n            });\r\n            ModelNodeRecordsAccessor.handleRecord(this, record);\r\n        }\r\n    }\r\n\r\n    remove(item: Model): void {\r\n        const _items = this.#items;\r\n        const index = _items.indexOf(item);\r\n        if (index > -1) {\r\n            const item = _items.splice(index, 1)[0];\r\n            const {parentNode} = this;\r\n            if (parentNode) {\r\n                item.setParent(null);\r\n            }\r\n            const record = new ModelChangeRecord({\r\n                target: this,\r\n                changeType: ModelChangeRecord.LIST_REMOVE,\r\n                removedIndex: index,\r\n                removedItems: [item]\r\n            });\r\n            ModelNodeRecordsAccessor.handleRecord(this, record);\r\n        }\r\n    }\r\n\r\n    clear(): void {\r\n        const items = this.#items;\r\n        const {length} = items;\r\n        if (length > 0) {\r\n            const removedItems = items.splice(0);\r\n            const {parentNode} = this;\r\n            if (parentNode) {\r\n                removedItems.forEach((removedItem_i) => {\r\n                    removedItem_i.setParent(null);\r\n                });\r\n            }\r\n            const record = new ModelChangeRecord({\r\n                target: this,\r\n                changeType: ModelChangeRecord.LIST_REMOVE,\r\n                removedIndex: 0,\r\n                removedItems: removedItems\r\n            });\r\n            ModelNodeRecordsAccessor.handleRecord(this, record);\r\n        }\r\n    }\r\n};\r\n\r\nvar ModelList: ModelListConstructor = ModelListBase!;\r\n\r\ninterface ModelChangeObserverConstructor {\r\n    prototype: ModelChangeObserver;\r\n    new(callback: (records: ModelChangeRecord[]) => void): ModelChangeObserver;\r\n}\r\n\r\ninterface ModelChangeObserver {\r\n    observe(node: ModelNode, options: ModelChangeObserverOptions): void;\r\n    unobserve(node: ModelNode): void;\r\n    disconnect(): void;\r\n}\r\n\r\ntype ModelChangeObserverOptions = {\r\n    properties?: boolean;\r\n    propertiesFilter?: string[];\r\n    childList?: boolean;\r\n    subtree?: boolean;\r\n}\r\n\r\nclass ModelChangeObserverBase implements ModelChangeObserver {\r\n    #callback: (records: ModelChangeRecord[]) => void;\r\n    #records: ModelChangeRecord[];\r\n    #disconnected: boolean;\r\n\r\n    #references: WeakMap<ModelNode, {\r\n        listener: (event: ModelEvent) => void,\r\n        options: ModelChangeObserverOptions\r\n    }>;\r\n\r\n    constructor(callback: (records: ModelChangeRecord[]) => void) {\r\n        this.#callback = callback;\r\n        this.#records = [];\r\n        this.#disconnected = false;\r\n        this.#references = new WeakMap();\r\n    }\r\n\r\n    observe(node: ModelNode, options: ModelChangeObserverOptions): void {\r\n        this.#disconnected = false;\r\n        const references = this.#references;\r\n        let reference = references.get(node);\r\n        if (!reference) {\r\n            const listener = this.#handleModelEvent.bind(this);\r\n            node.addEventListener(\"modelchange\", listener);\r\n            reference = {listener, options};\r\n            references.set(node, reference);\r\n        }\r\n        else {\r\n            references.set(node, reference);\r\n        }\r\n    }\r\n\r\n    unobserve(node: ModelNode): void {\r\n        const references = this.#references;\r\n        let reference = references.get(node);\r\n        if (reference) {\r\n            const {listener} = reference;\r\n            node.removeEventListener(\"modelchange\", listener);\r\n        }\r\n    }\r\n\r\n    disconnect(): void {\r\n        this.#records.splice(0);\r\n        this.#disconnected = true;\r\n    }\r\n\r\n    #trigger(): void {\r\n        const records = this.#records.splice(0);\r\n        if (records.length > 0) {\r\n            this.#callback(records);\r\n        }\r\n    }\r\n\r\n    #handleModelEvent(event: ModelEvent): void {\r\n        if (!this.#disconnected) {\r\n            const {target, currentTarget} = event;\r\n            const reference = this.#references.get(<ModelNode>currentTarget);\r\n            if (reference) {\r\n                const {options} = reference;\r\n                const {properties, propertiesFilter, childList, subtree} = options;\r\n                if (subtree) {\r\n                    if (properties && target instanceof ModelNode) {\r\n                        if (propertiesFilter) {\r\n                            this.#records.push(\r\n                                ...target.getRecords()\r\n                                    .filter(record_i => {\r\n                                        const {propertyName} = record_i;\r\n                                        return propertiesFilter.includes(\r\n                                            propertyName!\r\n                                        )\r\n                                    })\r\n                            );\r\n                        }\r\n                        else {\r\n                            this.#records.push(\r\n                                ...target.getRecords()\r\n                            );\r\n                        }\r\n                        this.#trigger();\r\n                    }\r\n                    else if (childList && target instanceof ModelList) {\r\n                        this.#records.push(\r\n                            ...target.getRecords()\r\n                        );\r\n                        this.#trigger();\r\n                    }\r\n                }\r\n                else if (target == currentTarget) {\r\n                    if (properties && target instanceof ModelNode) {\r\n                        if (propertiesFilter) {\r\n                            this.#records.push(\r\n                                ...target.getRecords()\r\n                                    .filter(record_i => {\r\n                                        const {propertyName} = record_i;\r\n                                        return propertiesFilter.includes(\r\n                                            propertyName!\r\n                                        )\r\n                                    })\r\n                            );\r\n                        }\r\n                        else {\r\n                            this.#records.push(\r\n                                ...target.getRecords()\r\n                            );\r\n                        }\r\n                        this.#trigger();\r\n                    }\r\n                    else if (childList && target instanceof ModelList) {\r\n                        this.#records.push(\r\n                            ...target.getRecords()\r\n                        );\r\n                        this.#trigger();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvar ModelChangeObserver: ModelChangeObserverConstructor = ModelChangeObserverBase;"],"names":["ModelChangeRecordBase","constructor","init","this","target","changeType","propertyName","oldValue","undefined","newValue","removedIndex","removedItems","ModelNodesList","insertedIndex","insertedItems","sortedIndices","PROPERTY_CHANGE","LIST_REMOVE","LIST_INSERT","LIST_SORT","ModelChangeRecord","items","slice","length","item","index","values","ModelEventBase","type","currentTarget","ModelEventTargetAccessor","setCurrentTarget","event","setTarget","ModelEvent","ModelEventTargetBase","Map","receiveEvent","callbacks","get","forEach","callback_i","addEventListener","callback","push","set","removeEventListener","callbackIndex","findIndex","splice","delete","dispatchEvent","ModelNodeBase","super","parentNode","setParent","isCyclicReference","ancestorNode","TypeError","beginChanges","endChanges","getRecords","property","records","record","ModelNodeRecordsAccessor","triggerChange","node","handleRecord","ModelObjectBase","ModelObjectPropertiesAccessor","setProperty","value","getProperty"],"sourceRoot":""}